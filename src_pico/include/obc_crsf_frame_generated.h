// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OBCCRSFFRAME_FBS_H_
#define FLATBUFFERS_GENERATED_OBCCRSFFRAME_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fbs {

struct Telemetry;
struct TelemetryBuilder;

struct Channels;

struct TxData;
struct TxDataBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Channels FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t data_[16];

 public:
  Channels()
      : data_() {
  }
  Channels(::flatbuffers::span<const uint16_t, 16> _data) {
    ::flatbuffers::CastToArray(data_).CopyFromSpan(_data);
  }
  const ::flatbuffers::Array<uint16_t, 16> *data() const {
    return &::flatbuffers::CastToArray(data_);
  }
};
FLATBUFFERS_STRUCT_END(Channels, 32);

struct Telemetry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TelemetryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RSSI = 4,
    VT_LINK_QUALITY = 6,
    VT_SNR = 8,
    VT_TX_POWER = 10
  };
  /// Signal strength indicator
  uint8_t rssi() const {
    return GetField<uint8_t>(VT_RSSI, 0);
  }
  /// Link quality
  uint8_t link_quality() const {
    return GetField<uint8_t>(VT_LINK_QUALITY, 0);
  }
  /// Signal to noise ratio
  int8_t snr() const {
    return GetField<int8_t>(VT_SNR, 0);
  }
  /// Transmission power
  uint16_t tx_power() const {
    return GetField<uint16_t>(VT_TX_POWER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_LINK_QUALITY, 1) &&
           VerifyField<int8_t>(verifier, VT_SNR, 1) &&
           VerifyField<uint16_t>(verifier, VT_TX_POWER, 2) &&
           verifier.EndTable();
  }
};

struct TelemetryBuilder {
  typedef Telemetry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rssi(uint8_t rssi) {
    fbb_.AddElement<uint8_t>(Telemetry::VT_RSSI, rssi, 0);
  }
  void add_link_quality(uint8_t link_quality) {
    fbb_.AddElement<uint8_t>(Telemetry::VT_LINK_QUALITY, link_quality, 0);
  }
  void add_snr(int8_t snr) {
    fbb_.AddElement<int8_t>(Telemetry::VT_SNR, snr, 0);
  }
  void add_tx_power(uint16_t tx_power) {
    fbb_.AddElement<uint16_t>(Telemetry::VT_TX_POWER, tx_power, 0);
  }
  explicit TelemetryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Telemetry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Telemetry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Telemetry> CreateTelemetry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t rssi = 0,
    uint8_t link_quality = 0,
    int8_t snr = 0,
    uint16_t tx_power = 0) {
  TelemetryBuilder builder_(_fbb);
  builder_.add_tx_power(tx_power);
  builder_.add_snr(snr);
  builder_.add_link_quality(link_quality);
  builder_.add_rssi(rssi);
  return builder_.Finish();
}

struct TxData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TxDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_TELEMETRY = 6,
    VT_FAILSAFE = 8
  };
  const fbs::Channels *channels() const {
    return GetStruct<const fbs::Channels *>(VT_CHANNELS);
  }
  /// Telemetry data associated with the RC frame
  const fbs::Telemetry *telemetry() const {
    return GetPointer<const fbs::Telemetry *>(VT_TELEMETRY);
  }
  /// Failsafe flag with a default value of true
  bool failsafe() const {
    return GetField<uint8_t>(VT_FAILSAFE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbs::Channels>(verifier, VT_CHANNELS, 2) &&
           VerifyOffset(verifier, VT_TELEMETRY) &&
           verifier.VerifyTable(telemetry()) &&
           VerifyField<uint8_t>(verifier, VT_FAILSAFE, 1) &&
           verifier.EndTable();
  }
};

struct TxDataBuilder {
  typedef TxData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channels(const fbs::Channels *channels) {
    fbb_.AddStruct(TxData::VT_CHANNELS, channels);
  }
  void add_telemetry(::flatbuffers::Offset<fbs::Telemetry> telemetry) {
    fbb_.AddOffset(TxData::VT_TELEMETRY, telemetry);
  }
  void add_failsafe(bool failsafe) {
    fbb_.AddElement<uint8_t>(TxData::VT_FAILSAFE, static_cast<uint8_t>(failsafe), 1);
  }
  explicit TxDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TxData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TxData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TxData> CreateTxData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fbs::Channels *channels = nullptr,
    ::flatbuffers::Offset<fbs::Telemetry> telemetry = 0,
    bool failsafe = true) {
  TxDataBuilder builder_(_fbb);
  builder_.add_telemetry(telemetry);
  builder_.add_channels(channels);
  builder_.add_failsafe(failsafe);
  return builder_.Finish();
}

inline const fbs::TxData *GetTxData(const void *buf) {
  return ::flatbuffers::GetRoot<fbs::TxData>(buf);
}

inline const fbs::TxData *GetSizePrefixedTxData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fbs::TxData>(buf);
}

inline const char *TxDataIdentifier() {
  return "OCDT";
}

inline bool TxDataBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TxDataIdentifier());
}

inline bool SizePrefixedTxDataBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TxDataIdentifier(), true);
}

inline bool VerifyTxDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbs::TxData>(TxDataIdentifier());
}

inline bool VerifySizePrefixedTxDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbs::TxData>(TxDataIdentifier());
}

inline void FinishTxDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::TxData> root) {
  fbb.Finish(root, TxDataIdentifier());
}

inline void FinishSizePrefixedTxDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::TxData> root) {
  fbb.FinishSizePrefixed(root, TxDataIdentifier());
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_OBCCRSFFRAME_FBS_H_
