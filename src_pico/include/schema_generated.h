// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_QOCTO_WSSCHEMA_H_
#define FLATBUFFERS_GENERATED_SCHEMA_QOCTO_WSSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace QOcto {
namespace WSSchema {

struct Motor;
struct MotorBuilder;

struct Motors;
struct MotorsBuilder;

struct Robot;
struct RobotBuilder;

struct UpdateBatteries;
struct UpdateBatteriesBuilder;

struct UpdateLowVoltageThreshold;
struct UpdateLowVoltageThresholdBuilder;

struct UpdateCriticalVoltageThreshold;
struct UpdateCriticalVoltageThresholdBuilder;

struct UpdateReferenceWheelAngle;
struct UpdateReferenceWheelAngleBuilder;

struct UpdateWheelsFolded;
struct UpdateWheelsFoldedBuilder;

struct UpdateEnableRover;
struct UpdateEnableRoverBuilder;

enum ControlSource : int8_t {
  ControlSource_Manual = 0,
  ControlSource_FlightController = 1,
  ControlSource_OnboardComputer = 2,
  ControlSource_RC = 3,
  ControlSource_MIN = ControlSource_Manual,
  ControlSource_MAX = ControlSource_RC
};

inline const ControlSource (&EnumValuesControlSource())[4] {
  static const ControlSource values[] = {
    ControlSource_Manual,
    ControlSource_FlightController,
    ControlSource_OnboardComputer,
    ControlSource_RC
  };
  return values;
}

inline const char * const *EnumNamesControlSource() {
  static const char * const names[5] = {
    "Manual",
    "FlightController",
    "OnboardComputer",
    "RC",
    nullptr
  };
  return names;
}

inline const char *EnumNameControlSource(ControlSource e) {
  if (::flatbuffers::IsOutRange(e, ControlSource_Manual, ControlSource_RC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesControlSource()[index];
}

enum Status : int8_t {
  Status_OK = 0,
  Status_INIT = 1,
  Status_NOTX = 2,
  Status_BAT = 3,
  Status_TEMP = 4,
  Status_OFF = 5,
  Status_MIN = Status_OK,
  Status_MAX = Status_OFF
};

inline const Status (&EnumValuesStatus())[6] {
  static const Status values[] = {
    Status_OK,
    Status_INIT,
    Status_NOTX,
    Status_BAT,
    Status_TEMP,
    Status_OFF
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[7] = {
    "OK",
    "INIT",
    "NOTX",
    "BAT",
    "TEMP",
    "OFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status_OK, Status_OFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum Update : uint8_t {
  Update_NONE = 0,
  Update_UpdateBatteries = 1,
  Update_UpdateLowVoltageThreshold = 2,
  Update_UpdateCriticalVoltageThreshold = 3,
  Update_UpdateReferenceWheelAngle = 4,
  Update_UpdateWheelsFolded = 5,
  Update_UpdateEnableRover = 6,
  Update_MIN = Update_NONE,
  Update_MAX = Update_UpdateEnableRover
};

inline const Update (&EnumValuesUpdate())[7] {
  static const Update values[] = {
    Update_NONE,
    Update_UpdateBatteries,
    Update_UpdateLowVoltageThreshold,
    Update_UpdateCriticalVoltageThreshold,
    Update_UpdateReferenceWheelAngle,
    Update_UpdateWheelsFolded,
    Update_UpdateEnableRover
  };
  return values;
}

inline const char * const *EnumNamesUpdate() {
  static const char * const names[8] = {
    "NONE",
    "UpdateBatteries",
    "UpdateLowVoltageThreshold",
    "UpdateCriticalVoltageThreshold",
    "UpdateReferenceWheelAngle",
    "UpdateWheelsFolded",
    "UpdateEnableRover",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdate(Update e) {
  if (::flatbuffers::IsOutRange(e, Update_NONE, Update_UpdateEnableRover)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdate()[index];
}

template<typename T> struct UpdateTraits {
  static const Update enum_value = Update_NONE;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateBatteries> {
  static const Update enum_value = Update_UpdateBatteries;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateLowVoltageThreshold> {
  static const Update enum_value = Update_UpdateLowVoltageThreshold;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateCriticalVoltageThreshold> {
  static const Update enum_value = Update_UpdateCriticalVoltageThreshold;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateReferenceWheelAngle> {
  static const Update enum_value = Update_UpdateReferenceWheelAngle;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateWheelsFolded> {
  static const Update enum_value = Update_UpdateWheelsFolded;
};

template<> struct UpdateTraits<QOcto::WSSchema::UpdateEnableRover> {
  static const Update enum_value = Update_UpdateEnableRover;
};

bool VerifyUpdate(::flatbuffers::Verifier &verifier, const void *obj, Update type);
bool VerifyUpdateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Motor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPERATURE = 4,
    VT_RPS = 6,
    VT_ANGLE = 8
  };
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  float rps() const {
    return GetField<float>(VT_RPS, 0.0f);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<float>(verifier, VT_RPS, 4) &&
           VerifyField<float>(verifier, VT_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct MotorBuilder {
  typedef Motor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(Motor::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_rps(float rps) {
    fbb_.AddElement<float>(Motor::VT_RPS, rps, 0.0f);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(Motor::VT_ANGLE, angle, 0.0f);
  }
  explicit MotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Motor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Motor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Motor> CreateMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float temperature = 0.0f,
    float rps = 0.0f,
    float angle = 0.0f) {
  MotorBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_rps(rps);
  builder_.add_temperature(temperature);
  return builder_.Finish();
}

struct Motors FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOTOR1 = 4,
    VT_MOTOR2 = 6
  };
  const QOcto::WSSchema::Motor *motor1() const {
    return GetPointer<const QOcto::WSSchema::Motor *>(VT_MOTOR1);
  }
  const QOcto::WSSchema::Motor *motor2() const {
    return GetPointer<const QOcto::WSSchema::Motor *>(VT_MOTOR2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOTOR1) &&
           verifier.VerifyTable(motor1()) &&
           VerifyOffset(verifier, VT_MOTOR2) &&
           verifier.VerifyTable(motor2()) &&
           verifier.EndTable();
  }
};

struct MotorsBuilder {
  typedef Motors Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_motor1(::flatbuffers::Offset<QOcto::WSSchema::Motor> motor1) {
    fbb_.AddOffset(Motors::VT_MOTOR1, motor1);
  }
  void add_motor2(::flatbuffers::Offset<QOcto::WSSchema::Motor> motor2) {
    fbb_.AddOffset(Motors::VT_MOTOR2, motor2);
  }
  explicit MotorsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Motors> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Motors>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Motors> CreateMotors(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<QOcto::WSSchema::Motor> motor1 = 0,
    ::flatbuffers::Offset<QOcto::WSSchema::Motor> motor2 = 0) {
  MotorsBuilder builder_(_fbb);
  builder_.add_motor2(motor2);
  builder_.add_motor1(motor1);
  return builder_.Finish();
}

struct Robot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERIES = 4,
    VT_CONTROL_SOURCE = 6,
    VT_STATUS = 8,
    VT_MOTORS = 10,
    VT_VOLTAGE = 12,
    VT_CURRENT = 14,
    VT_FUEL = 16,
    VT_RSSI = 18,
    VT_SIGNAL_STRENGTH = 20,
    VT_MAX_SPEED = 22,
    VT_LOW_VOLTAGE_THRESHOLD = 24,
    VT_CRITICAL_VOLTAGE_THRESHOLD = 26,
    VT_REFERENCE_WHEEL_ANGLE = 28,
    VT_MOTOR_ERROR_CODE = 30,
    VT_WHEELS_FOLDED = 32,
    VT_ENABLE_ROVER = 34
  };
  int32_t batteries() const {
    return GetField<int32_t>(VT_BATTERIES, 4);
  }
  QOcto::WSSchema::ControlSource control_source() const {
    return static_cast<QOcto::WSSchema::ControlSource>(GetField<int8_t>(VT_CONTROL_SOURCE, 3));
  }
  QOcto::WSSchema::Status status() const {
    return static_cast<QOcto::WSSchema::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const QOcto::WSSchema::Motors *motors() const {
    return GetPointer<const QOcto::WSSchema::Motors *>(VT_MOTORS);
  }
  float voltage() const {
    return GetField<float>(VT_VOLTAGE, 0.0f);
  }
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  float fuel() const {
    return GetField<float>(VT_FUEL, 0.0f);
  }
  float rssi() const {
    return GetField<float>(VT_RSSI, 0.0f);
  }
  int32_t signal_strength() const {
    return GetField<int32_t>(VT_SIGNAL_STRENGTH, 0);
  }
  float max_speed() const {
    return GetField<float>(VT_MAX_SPEED, 0.0f);
  }
  float low_voltage_threshold() const {
    return GetField<float>(VT_LOW_VOLTAGE_THRESHOLD, 12.0f);
  }
  float critical_voltage_threshold() const {
    return GetField<float>(VT_CRITICAL_VOLTAGE_THRESHOLD, 16.0f);
  }
  int32_t reference_wheel_angle() const {
    return GetField<int32_t>(VT_REFERENCE_WHEEL_ANGLE, 0);
  }
  const ::flatbuffers::String *motor_error_code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTOR_ERROR_CODE);
  }
  bool wheels_folded() const {
    return GetField<uint8_t>(VT_WHEELS_FOLDED, 0) != 0;
  }
  bool enable_rover() const {
    return GetField<uint8_t>(VT_ENABLE_ROVER, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATTERIES, 4) &&
           VerifyField<int8_t>(verifier, VT_CONTROL_SOURCE, 1) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_MOTORS) &&
           verifier.VerifyTable(motors()) &&
           VerifyField<float>(verifier, VT_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           VerifyField<float>(verifier, VT_FUEL, 4) &&
           VerifyField<float>(verifier, VT_RSSI, 4) &&
           VerifyField<int32_t>(verifier, VT_SIGNAL_STRENGTH, 4) &&
           VerifyField<float>(verifier, VT_MAX_SPEED, 4) &&
           VerifyField<float>(verifier, VT_LOW_VOLTAGE_THRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_CRITICAL_VOLTAGE_THRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_REFERENCE_WHEEL_ANGLE, 4) &&
           VerifyOffset(verifier, VT_MOTOR_ERROR_CODE) &&
           verifier.VerifyString(motor_error_code()) &&
           VerifyField<uint8_t>(verifier, VT_WHEELS_FOLDED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ROVER, 1) &&
           verifier.EndTable();
  }
};

struct RobotBuilder {
  typedef Robot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_batteries(int32_t batteries) {
    fbb_.AddElement<int32_t>(Robot::VT_BATTERIES, batteries, 4);
  }
  void add_control_source(QOcto::WSSchema::ControlSource control_source) {
    fbb_.AddElement<int8_t>(Robot::VT_CONTROL_SOURCE, static_cast<int8_t>(control_source), 3);
  }
  void add_status(QOcto::WSSchema::Status status) {
    fbb_.AddElement<int8_t>(Robot::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_motors(::flatbuffers::Offset<QOcto::WSSchema::Motors> motors) {
    fbb_.AddOffset(Robot::VT_MOTORS, motors);
  }
  void add_voltage(float voltage) {
    fbb_.AddElement<float>(Robot::VT_VOLTAGE, voltage, 0.0f);
  }
  void add_current(float current) {
    fbb_.AddElement<float>(Robot::VT_CURRENT, current, 0.0f);
  }
  void add_fuel(float fuel) {
    fbb_.AddElement<float>(Robot::VT_FUEL, fuel, 0.0f);
  }
  void add_rssi(float rssi) {
    fbb_.AddElement<float>(Robot::VT_RSSI, rssi, 0.0f);
  }
  void add_signal_strength(int32_t signal_strength) {
    fbb_.AddElement<int32_t>(Robot::VT_SIGNAL_STRENGTH, signal_strength, 0);
  }
  void add_max_speed(float max_speed) {
    fbb_.AddElement<float>(Robot::VT_MAX_SPEED, max_speed, 0.0f);
  }
  void add_low_voltage_threshold(float low_voltage_threshold) {
    fbb_.AddElement<float>(Robot::VT_LOW_VOLTAGE_THRESHOLD, low_voltage_threshold, 12.0f);
  }
  void add_critical_voltage_threshold(float critical_voltage_threshold) {
    fbb_.AddElement<float>(Robot::VT_CRITICAL_VOLTAGE_THRESHOLD, critical_voltage_threshold, 16.0f);
  }
  void add_reference_wheel_angle(int32_t reference_wheel_angle) {
    fbb_.AddElement<int32_t>(Robot::VT_REFERENCE_WHEEL_ANGLE, reference_wheel_angle, 0);
  }
  void add_motor_error_code(::flatbuffers::Offset<::flatbuffers::String> motor_error_code) {
    fbb_.AddOffset(Robot::VT_MOTOR_ERROR_CODE, motor_error_code);
  }
  void add_wheels_folded(bool wheels_folded) {
    fbb_.AddElement<uint8_t>(Robot::VT_WHEELS_FOLDED, static_cast<uint8_t>(wheels_folded), 0);
  }
  void add_enable_rover(bool enable_rover) {
    fbb_.AddElement<uint8_t>(Robot::VT_ENABLE_ROVER, static_cast<uint8_t>(enable_rover), 0);
  }
  explicit RobotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Robot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Robot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Robot> CreateRobot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batteries = 4,
    QOcto::WSSchema::ControlSource control_source = QOcto::WSSchema::ControlSource_RC,
    QOcto::WSSchema::Status status = QOcto::WSSchema::Status_OK,
    ::flatbuffers::Offset<QOcto::WSSchema::Motors> motors = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float fuel = 0.0f,
    float rssi = 0.0f,
    int32_t signal_strength = 0,
    float max_speed = 0.0f,
    float low_voltage_threshold = 12.0f,
    float critical_voltage_threshold = 16.0f,
    int32_t reference_wheel_angle = 0,
    ::flatbuffers::Offset<::flatbuffers::String> motor_error_code = 0,
    bool wheels_folded = false,
    bool enable_rover = false) {
  RobotBuilder builder_(_fbb);
  builder_.add_motor_error_code(motor_error_code);
  builder_.add_reference_wheel_angle(reference_wheel_angle);
  builder_.add_critical_voltage_threshold(critical_voltage_threshold);
  builder_.add_low_voltage_threshold(low_voltage_threshold);
  builder_.add_max_speed(max_speed);
  builder_.add_signal_strength(signal_strength);
  builder_.add_rssi(rssi);
  builder_.add_fuel(fuel);
  builder_.add_current(current);
  builder_.add_voltage(voltage);
  builder_.add_motors(motors);
  builder_.add_batteries(batteries);
  builder_.add_enable_rover(enable_rover);
  builder_.add_wheels_folded(wheels_folded);
  builder_.add_status(status);
  builder_.add_control_source(control_source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Robot> CreateRobotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batteries = 4,
    QOcto::WSSchema::ControlSource control_source = QOcto::WSSchema::ControlSource_RC,
    QOcto::WSSchema::Status status = QOcto::WSSchema::Status_OK,
    ::flatbuffers::Offset<QOcto::WSSchema::Motors> motors = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float fuel = 0.0f,
    float rssi = 0.0f,
    int32_t signal_strength = 0,
    float max_speed = 0.0f,
    float low_voltage_threshold = 12.0f,
    float critical_voltage_threshold = 16.0f,
    int32_t reference_wheel_angle = 0,
    const char *motor_error_code = nullptr,
    bool wheels_folded = false,
    bool enable_rover = false) {
  auto motor_error_code__ = motor_error_code ? _fbb.CreateString(motor_error_code) : 0;
  return QOcto::WSSchema::CreateRobot(
      _fbb,
      batteries,
      control_source,
      status,
      motors,
      voltage,
      current,
      fuel,
      rssi,
      signal_strength,
      max_speed,
      low_voltage_threshold,
      critical_voltage_threshold,
      reference_wheel_angle,
      motor_error_code__,
      wheels_folded,
      enable_rover);
}

struct UpdateBatteries FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateBatteriesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERIES = 4
  };
  int32_t batteries() const {
    return GetField<int32_t>(VT_BATTERIES, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATTERIES, 4) &&
           verifier.EndTable();
  }
};

struct UpdateBatteriesBuilder {
  typedef UpdateBatteries Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_batteries(int32_t batteries) {
    fbb_.AddElement<int32_t>(UpdateBatteries::VT_BATTERIES, batteries, 0);
  }
  explicit UpdateBatteriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateBatteries> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateBatteries>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateBatteries> CreateUpdateBatteries(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batteries = 0) {
  UpdateBatteriesBuilder builder_(_fbb);
  builder_.add_batteries(batteries);
  return builder_.Finish();
}

struct UpdateLowVoltageThreshold FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateLowVoltageThresholdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW_VOLTAGE_THRESHOLD = 4
  };
  float low_voltage_threshold() const {
    return GetField<float>(VT_LOW_VOLTAGE_THRESHOLD, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LOW_VOLTAGE_THRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct UpdateLowVoltageThresholdBuilder {
  typedef UpdateLowVoltageThreshold Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_low_voltage_threshold(float low_voltage_threshold) {
    fbb_.AddElement<float>(UpdateLowVoltageThreshold::VT_LOW_VOLTAGE_THRESHOLD, low_voltage_threshold, 0.0f);
  }
  explicit UpdateLowVoltageThresholdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateLowVoltageThreshold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateLowVoltageThreshold>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateLowVoltageThreshold> CreateUpdateLowVoltageThreshold(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float low_voltage_threshold = 0.0f) {
  UpdateLowVoltageThresholdBuilder builder_(_fbb);
  builder_.add_low_voltage_threshold(low_voltage_threshold);
  return builder_.Finish();
}

struct UpdateCriticalVoltageThreshold FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateCriticalVoltageThresholdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRITICAL_VOLTAGE_THRESHOLD = 4
  };
  float critical_voltage_threshold() const {
    return GetField<float>(VT_CRITICAL_VOLTAGE_THRESHOLD, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CRITICAL_VOLTAGE_THRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct UpdateCriticalVoltageThresholdBuilder {
  typedef UpdateCriticalVoltageThreshold Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_critical_voltage_threshold(float critical_voltage_threshold) {
    fbb_.AddElement<float>(UpdateCriticalVoltageThreshold::VT_CRITICAL_VOLTAGE_THRESHOLD, critical_voltage_threshold, 0.0f);
  }
  explicit UpdateCriticalVoltageThresholdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateCriticalVoltageThreshold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateCriticalVoltageThreshold>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateCriticalVoltageThreshold> CreateUpdateCriticalVoltageThreshold(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float critical_voltage_threshold = 0.0f) {
  UpdateCriticalVoltageThresholdBuilder builder_(_fbb);
  builder_.add_critical_voltage_threshold(critical_voltage_threshold);
  return builder_.Finish();
}

struct UpdateReferenceWheelAngle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateReferenceWheelAngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_WHEEL_ANGLE = 4
  };
  int32_t reference_wheel_angle() const {
    return GetField<int32_t>(VT_REFERENCE_WHEEL_ANGLE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REFERENCE_WHEEL_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct UpdateReferenceWheelAngleBuilder {
  typedef UpdateReferenceWheelAngle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reference_wheel_angle(int32_t reference_wheel_angle) {
    fbb_.AddElement<int32_t>(UpdateReferenceWheelAngle::VT_REFERENCE_WHEEL_ANGLE, reference_wheel_angle, 0);
  }
  explicit UpdateReferenceWheelAngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateReferenceWheelAngle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateReferenceWheelAngle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateReferenceWheelAngle> CreateUpdateReferenceWheelAngle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reference_wheel_angle = 0) {
  UpdateReferenceWheelAngleBuilder builder_(_fbb);
  builder_.add_reference_wheel_angle(reference_wheel_angle);
  return builder_.Finish();
}

struct UpdateWheelsFolded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateWheelsFoldedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHEELS_FOLDED = 4
  };
  bool wheels_folded() const {
    return GetField<uint8_t>(VT_WHEELS_FOLDED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WHEELS_FOLDED, 1) &&
           verifier.EndTable();
  }
};

struct UpdateWheelsFoldedBuilder {
  typedef UpdateWheelsFolded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wheels_folded(bool wheels_folded) {
    fbb_.AddElement<uint8_t>(UpdateWheelsFolded::VT_WHEELS_FOLDED, static_cast<uint8_t>(wheels_folded), 0);
  }
  explicit UpdateWheelsFoldedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateWheelsFolded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateWheelsFolded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateWheelsFolded> CreateUpdateWheelsFolded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool wheels_folded = false) {
  UpdateWheelsFoldedBuilder builder_(_fbb);
  builder_.add_wheels_folded(wheels_folded);
  return builder_.Finish();
}

struct UpdateEnableRover FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateEnableRoverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE_ROVER = 4
  };
  bool enable_rover() const {
    return GetField<uint8_t>(VT_ENABLE_ROVER, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ROVER, 1) &&
           verifier.EndTable();
  }
};

struct UpdateEnableRoverBuilder {
  typedef UpdateEnableRover Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enable_rover(bool enable_rover) {
    fbb_.AddElement<uint8_t>(UpdateEnableRover::VT_ENABLE_ROVER, static_cast<uint8_t>(enable_rover), 0);
  }
  explicit UpdateEnableRoverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateEnableRover> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateEnableRover>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateEnableRover> CreateUpdateEnableRover(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enable_rover = false) {
  UpdateEnableRoverBuilder builder_(_fbb);
  builder_.add_enable_rover(enable_rover);
  return builder_.Finish();
}

inline bool VerifyUpdate(::flatbuffers::Verifier &verifier, const void *obj, Update type) {
  switch (type) {
    case Update_NONE: {
      return true;
    }
    case Update_UpdateBatteries: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateBatteries *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Update_UpdateLowVoltageThreshold: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateLowVoltageThreshold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Update_UpdateCriticalVoltageThreshold: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateCriticalVoltageThreshold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Update_UpdateReferenceWheelAngle: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateReferenceWheelAngle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Update_UpdateWheelsFolded: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateWheelsFolded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Update_UpdateEnableRover: {
      auto ptr = reinterpret_cast<const QOcto::WSSchema::UpdateEnableRover *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUpdateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUpdate(
        verifier,  values->Get(i), types->GetEnum<Update>(i))) {
      return false;
    }
  }
  return true;
}

inline const QOcto::WSSchema::Robot *GetRobot(const void *buf) {
  return ::flatbuffers::GetRoot<QOcto::WSSchema::Robot>(buf);
}

inline const QOcto::WSSchema::Robot *GetSizePrefixedRobot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<QOcto::WSSchema::Robot>(buf);
}

inline bool VerifyRobotBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<QOcto::WSSchema::Robot>(nullptr);
}

inline bool VerifySizePrefixedRobotBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<QOcto::WSSchema::Robot>(nullptr);
}

inline void FinishRobotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<QOcto::WSSchema::Robot> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRobotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<QOcto::WSSchema::Robot> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace WSSchema
}  // namespace QOcto

#endif  // FLATBUFFERS_GENERATED_SCHEMA_QOCTO_WSSCHEMA_H_
