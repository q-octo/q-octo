// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WSROBOT_FBS_H_
#define FLATBUFFERS_GENERATED_WSROBOT_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fbs {

struct Motor;
struct MotorBuilder;

struct Motors;
struct MotorsBuilder;

struct Robot;
struct RobotBuilder;

enum ControlSource : int8_t {
  ControlSource_Manual = 0,
  ControlSource_FlightController = 1,
  ControlSource_OnboardComputer = 2,
  ControlSource_RC = 3,
  ControlSource_MIN = ControlSource_Manual,
  ControlSource_MAX = ControlSource_RC
};

inline const ControlSource (&EnumValuesControlSource())[4] {
  static const ControlSource values[] = {
    ControlSource_Manual,
    ControlSource_FlightController,
    ControlSource_OnboardComputer,
    ControlSource_RC
  };
  return values;
}

inline const char * const *EnumNamesControlSource() {
  static const char * const names[5] = {
    "Manual",
    "FlightController",
    "OnboardComputer",
    "RC",
    nullptr
  };
  return names;
}

inline const char *EnumNameControlSource(ControlSource e) {
  if (::flatbuffers::IsOutRange(e, ControlSource_Manual, ControlSource_RC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesControlSource()[index];
}

enum Status : int8_t {
  Status_OK = 0,
  Status_INIT = 1,
  Status_NOTX = 2,
  Status_BAT = 3,
  Status_TEMP = 4,
  Status_OFF = 5,
  Status_MIN = Status_OK,
  Status_MAX = Status_OFF
};

inline const Status (&EnumValuesStatus())[6] {
  static const Status values[] = {
    Status_OK,
    Status_INIT,
    Status_NOTX,
    Status_BAT,
    Status_TEMP,
    Status_OFF
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[7] = {
    "OK",
    "INIT",
    "NOTX",
    "BAT",
    "TEMP",
    "OFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status_OK, Status_OFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

struct Motor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPERATURE = 4,
    VT_RPS = 6,
    VT_ANGLE = 8
  };
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  float rps() const {
    return GetField<float>(VT_RPS, 0.0f);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<float>(verifier, VT_RPS, 4) &&
           VerifyField<float>(verifier, VT_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct MotorBuilder {
  typedef Motor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(Motor::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_rps(float rps) {
    fbb_.AddElement<float>(Motor::VT_RPS, rps, 0.0f);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(Motor::VT_ANGLE, angle, 0.0f);
  }
  explicit MotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Motor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Motor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Motor> CreateMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float temperature = 0.0f,
    float rps = 0.0f,
    float angle = 0.0f) {
  MotorBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_rps(rps);
  builder_.add_temperature(temperature);
  return builder_.Finish();
}

struct Motors FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOTOR1 = 4,
    VT_MOTOR2 = 6
  };
  const fbs::Motor *motor1() const {
    return GetPointer<const fbs::Motor *>(VT_MOTOR1);
  }
  const fbs::Motor *motor2() const {
    return GetPointer<const fbs::Motor *>(VT_MOTOR2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOTOR1) &&
           verifier.VerifyTable(motor1()) &&
           VerifyOffset(verifier, VT_MOTOR2) &&
           verifier.VerifyTable(motor2()) &&
           verifier.EndTable();
  }
};

struct MotorsBuilder {
  typedef Motors Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_motor1(::flatbuffers::Offset<fbs::Motor> motor1) {
    fbb_.AddOffset(Motors::VT_MOTOR1, motor1);
  }
  void add_motor2(::flatbuffers::Offset<fbs::Motor> motor2) {
    fbb_.AddOffset(Motors::VT_MOTOR2, motor2);
  }
  explicit MotorsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Motors> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Motors>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Motors> CreateMotors(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Motor> motor1 = 0,
    ::flatbuffers::Offset<fbs::Motor> motor2 = 0) {
  MotorsBuilder builder_(_fbb);
  builder_.add_motor2(motor2);
  builder_.add_motor1(motor1);
  return builder_.Finish();
}

struct Robot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERIES = 4,
    VT_CONTROL_SOURCE = 6,
    VT_STATUS = 8,
    VT_MOTORS = 10,
    VT_VOLTAGE = 12,
    VT_CURRENT = 14,
    VT_FUEL = 16,
    VT_RSSI = 18,
    VT_SIGNAL_STRENGTH = 20,
    VT_MAX_SPEED = 22,
    VT_LOW_VOLTAGE_THRESHOLD = 24,
    VT_CRITICAL_VOLTAGE_THRESHOLD = 26,
    VT_REFERENCE_WHEEL_ANGLE = 28,
    VT_MOTOR_ERROR_CODE = 30,
    VT_WHEELS_FOLDED = 32,
    VT_ENABLE_ROVER = 34
  };
  int32_t batteries() const {
    return GetField<int32_t>(VT_BATTERIES, 4);
  }
  fbs::ControlSource control_source() const {
    return static_cast<fbs::ControlSource>(GetField<int8_t>(VT_CONTROL_SOURCE, 3));
  }
  fbs::Status status() const {
    return static_cast<fbs::Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const fbs::Motors *motors() const {
    return GetPointer<const fbs::Motors *>(VT_MOTORS);
  }
  float voltage() const {
    return GetField<float>(VT_VOLTAGE, 0.0f);
  }
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  float fuel() const {
    return GetField<float>(VT_FUEL, 0.0f);
  }
  float rssi() const {
    return GetField<float>(VT_RSSI, 0.0f);
  }
  int32_t signal_strength() const {
    return GetField<int32_t>(VT_SIGNAL_STRENGTH, 0);
  }
  float max_speed() const {
    return GetField<float>(VT_MAX_SPEED, 0.0f);
  }
  float low_voltage_threshold() const {
    return GetField<float>(VT_LOW_VOLTAGE_THRESHOLD, 12.0f);
  }
  float critical_voltage_threshold() const {
    return GetField<float>(VT_CRITICAL_VOLTAGE_THRESHOLD, 16.0f);
  }
  int32_t reference_wheel_angle() const {
    return GetField<int32_t>(VT_REFERENCE_WHEEL_ANGLE, 0);
  }
  const ::flatbuffers::String *motor_error_code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTOR_ERROR_CODE);
  }
  bool wheels_folded() const {
    return GetField<uint8_t>(VT_WHEELS_FOLDED, 0) != 0;
  }
  bool enable_rover() const {
    return GetField<uint8_t>(VT_ENABLE_ROVER, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATTERIES, 4) &&
           VerifyField<int8_t>(verifier, VT_CONTROL_SOURCE, 1) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_MOTORS) &&
           verifier.VerifyTable(motors()) &&
           VerifyField<float>(verifier, VT_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           VerifyField<float>(verifier, VT_FUEL, 4) &&
           VerifyField<float>(verifier, VT_RSSI, 4) &&
           VerifyField<int32_t>(verifier, VT_SIGNAL_STRENGTH, 4) &&
           VerifyField<float>(verifier, VT_MAX_SPEED, 4) &&
           VerifyField<float>(verifier, VT_LOW_VOLTAGE_THRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_CRITICAL_VOLTAGE_THRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_REFERENCE_WHEEL_ANGLE, 4) &&
           VerifyOffset(verifier, VT_MOTOR_ERROR_CODE) &&
           verifier.VerifyString(motor_error_code()) &&
           VerifyField<uint8_t>(verifier, VT_WHEELS_FOLDED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ROVER, 1) &&
           verifier.EndTable();
  }
};

struct RobotBuilder {
  typedef Robot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_batteries(int32_t batteries) {
    fbb_.AddElement<int32_t>(Robot::VT_BATTERIES, batteries, 4);
  }
  void add_control_source(fbs::ControlSource control_source) {
    fbb_.AddElement<int8_t>(Robot::VT_CONTROL_SOURCE, static_cast<int8_t>(control_source), 3);
  }
  void add_status(fbs::Status status) {
    fbb_.AddElement<int8_t>(Robot::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_motors(::flatbuffers::Offset<fbs::Motors> motors) {
    fbb_.AddOffset(Robot::VT_MOTORS, motors);
  }
  void add_voltage(float voltage) {
    fbb_.AddElement<float>(Robot::VT_VOLTAGE, voltage, 0.0f);
  }
  void add_current(float current) {
    fbb_.AddElement<float>(Robot::VT_CURRENT, current, 0.0f);
  }
  void add_fuel(float fuel) {
    fbb_.AddElement<float>(Robot::VT_FUEL, fuel, 0.0f);
  }
  void add_rssi(float rssi) {
    fbb_.AddElement<float>(Robot::VT_RSSI, rssi, 0.0f);
  }
  void add_signal_strength(int32_t signal_strength) {
    fbb_.AddElement<int32_t>(Robot::VT_SIGNAL_STRENGTH, signal_strength, 0);
  }
  void add_max_speed(float max_speed) {
    fbb_.AddElement<float>(Robot::VT_MAX_SPEED, max_speed, 0.0f);
  }
  void add_low_voltage_threshold(float low_voltage_threshold) {
    fbb_.AddElement<float>(Robot::VT_LOW_VOLTAGE_THRESHOLD, low_voltage_threshold, 12.0f);
  }
  void add_critical_voltage_threshold(float critical_voltage_threshold) {
    fbb_.AddElement<float>(Robot::VT_CRITICAL_VOLTAGE_THRESHOLD, critical_voltage_threshold, 16.0f);
  }
  void add_reference_wheel_angle(int32_t reference_wheel_angle) {
    fbb_.AddElement<int32_t>(Robot::VT_REFERENCE_WHEEL_ANGLE, reference_wheel_angle, 0);
  }
  void add_motor_error_code(::flatbuffers::Offset<::flatbuffers::String> motor_error_code) {
    fbb_.AddOffset(Robot::VT_MOTOR_ERROR_CODE, motor_error_code);
  }
  void add_wheels_folded(bool wheels_folded) {
    fbb_.AddElement<uint8_t>(Robot::VT_WHEELS_FOLDED, static_cast<uint8_t>(wheels_folded), 0);
  }
  void add_enable_rover(bool enable_rover) {
    fbb_.AddElement<uint8_t>(Robot::VT_ENABLE_ROVER, static_cast<uint8_t>(enable_rover), 0);
  }
  explicit RobotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Robot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Robot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Robot> CreateRobot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batteries = 4,
    fbs::ControlSource control_source = fbs::ControlSource_RC,
    fbs::Status status = fbs::Status_OK,
    ::flatbuffers::Offset<fbs::Motors> motors = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float fuel = 0.0f,
    float rssi = 0.0f,
    int32_t signal_strength = 0,
    float max_speed = 0.0f,
    float low_voltage_threshold = 12.0f,
    float critical_voltage_threshold = 16.0f,
    int32_t reference_wheel_angle = 0,
    ::flatbuffers::Offset<::flatbuffers::String> motor_error_code = 0,
    bool wheels_folded = false,
    bool enable_rover = false) {
  RobotBuilder builder_(_fbb);
  builder_.add_motor_error_code(motor_error_code);
  builder_.add_reference_wheel_angle(reference_wheel_angle);
  builder_.add_critical_voltage_threshold(critical_voltage_threshold);
  builder_.add_low_voltage_threshold(low_voltage_threshold);
  builder_.add_max_speed(max_speed);
  builder_.add_signal_strength(signal_strength);
  builder_.add_rssi(rssi);
  builder_.add_fuel(fuel);
  builder_.add_current(current);
  builder_.add_voltage(voltage);
  builder_.add_motors(motors);
  builder_.add_batteries(batteries);
  builder_.add_enable_rover(enable_rover);
  builder_.add_wheels_folded(wheels_folded);
  builder_.add_status(status);
  builder_.add_control_source(control_source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Robot> CreateRobotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batteries = 4,
    fbs::ControlSource control_source = fbs::ControlSource_RC,
    fbs::Status status = fbs::Status_OK,
    ::flatbuffers::Offset<fbs::Motors> motors = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float fuel = 0.0f,
    float rssi = 0.0f,
    int32_t signal_strength = 0,
    float max_speed = 0.0f,
    float low_voltage_threshold = 12.0f,
    float critical_voltage_threshold = 16.0f,
    int32_t reference_wheel_angle = 0,
    const char *motor_error_code = nullptr,
    bool wheels_folded = false,
    bool enable_rover = false) {
  auto motor_error_code__ = motor_error_code ? _fbb.CreateString(motor_error_code) : 0;
  return fbs::CreateRobot(
      _fbb,
      batteries,
      control_source,
      status,
      motors,
      voltage,
      current,
      fuel,
      rssi,
      signal_strength,
      max_speed,
      low_voltage_threshold,
      critical_voltage_threshold,
      reference_wheel_angle,
      motor_error_code__,
      wheels_folded,
      enable_rover);
}

inline const fbs::Robot *GetRobot(const void *buf) {
  return ::flatbuffers::GetRoot<fbs::Robot>(buf);
}

inline const fbs::Robot *GetSizePrefixedRobot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fbs::Robot>(buf);
}

inline const char *RobotIdentifier() {
  return "ROBO";
}

inline bool RobotBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RobotIdentifier());
}

inline bool SizePrefixedRobotBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RobotIdentifier(), true);
}

inline bool VerifyRobotBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbs::Robot>(RobotIdentifier());
}

inline bool VerifySizePrefixedRobotBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbs::Robot>(RobotIdentifier());
}

inline void FinishRobotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::Robot> root) {
  fbb.Finish(root, RobotIdentifier());
}

inline void FinishSizePrefixedRobotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::Robot> root) {
  fbb.FinishSizePrefixed(root, RobotIdentifier());
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_WSROBOT_FBS_H_
