// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEBUGROTARYENCODER_MOTORCONTROL_H_
#define FLATBUFFERS_GENERATED_DEBUGROTARYENCODER_MOTORCONTROL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace MotorControl {

struct InitMotor;
struct InitMotorBuilder;
struct InitMotorT;

struct EnableMotor;
struct EnableMotorBuilder;
struct EnableMotorT;

struct StopMotor;
struct StopMotorBuilder;
struct StopMotorT;

struct SetRunMode;
struct SetRunModeBuilder;
struct SetRunModeT;

struct SendMotionControl;
struct SendMotionControlBuilder;
struct SendMotionControlT;

struct SetLimitSpeed;
struct SetLimitSpeedBuilder;
struct SetLimitSpeedT;

struct SetLimitCurrent;
struct SetLimitCurrentBuilder;
struct SetLimitCurrentT;

struct SetLimitTorque;
struct SetLimitTorqueBuilder;
struct SetLimitTorqueT;

struct SetCurrentKp;
struct SetCurrentKpBuilder;
struct SetCurrentKpT;

struct SetCurrentKi;
struct SetCurrentKiBuilder;
struct SetCurrentKiT;

struct SetCurrentFilterGain;
struct SetCurrentFilterGainBuilder;
struct SetCurrentFilterGainT;

struct SetCurrentRef;
struct SetCurrentRefBuilder;
struct SetCurrentRefT;

struct SetPositionKp;
struct SetPositionKpBuilder;
struct SetPositionKpT;

struct SetPositionRef;
struct SetPositionRefBuilder;
struct SetPositionRefT;

struct SetSpeedKp;
struct SetSpeedKpBuilder;
struct SetSpeedKpT;

struct SetSpeedKi;
struct SetSpeedKiBuilder;
struct SetSpeedKiT;

struct SetSpeedRef;
struct SetSpeedRefBuilder;
struct SetSpeedRefT;

struct MotorCommand;
struct MotorCommandBuilder;
struct MotorCommandT;

struct EnableExtendedMode;
struct EnableExtendedModeBuilder;
struct EnableExtendedModeT;

struct StartMotor;
struct StartMotorBuilder;
struct StartMotorT;

struct TorqueControlMode;
struct TorqueControlModeBuilder;
struct TorqueControlModeT;

struct SpeedTorqueControlMode;
struct SpeedTorqueControlModeBuilder;
struct SpeedTorqueControlModeT;

struct PositionSpeedTorqueMode;
struct PositionSpeedTorqueModeBuilder;
struct PositionSpeedTorqueModeT;

struct SetMotorPositionToZero;
struct SetMotorPositionToZeroBuilder;
struct SetMotorPositionToZeroT;

struct MoveMotor;
struct MoveMotorBuilder;
struct MoveMotorT;

struct EncoderCommand;
struct EncoderCommandBuilder;
struct EncoderCommandT;

struct Command;
struct CommandBuilder;
struct CommandT;

enum MotorCommands : uint8_t {
  MotorCommands_NONE = 0,
  MotorCommands_InitMotor = 1,
  MotorCommands_EnableMotor = 2,
  MotorCommands_StopMotor = 3,
  MotorCommands_SetRunMode = 4,
  MotorCommands_SendMotionControl = 5,
  MotorCommands_SetLimitSpeed = 6,
  MotorCommands_SetLimitCurrent = 7,
  MotorCommands_SetLimitTorque = 8,
  MotorCommands_SetCurrentKp = 9,
  MotorCommands_SetCurrentKi = 10,
  MotorCommands_SetCurrentFilterGain = 11,
  MotorCommands_SetCurrentRef = 12,
  MotorCommands_SetPositionKp = 13,
  MotorCommands_SetPositionRef = 14,
  MotorCommands_SetSpeedKp = 15,
  MotorCommands_SetSpeedKi = 16,
  MotorCommands_SetSpeedRef = 17,
  MotorCommands_MIN = MotorCommands_NONE,
  MotorCommands_MAX = MotorCommands_SetSpeedRef
};

inline const MotorCommands (&EnumValuesMotorCommands())[18] {
  static const MotorCommands values[] = {
    MotorCommands_NONE,
    MotorCommands_InitMotor,
    MotorCommands_EnableMotor,
    MotorCommands_StopMotor,
    MotorCommands_SetRunMode,
    MotorCommands_SendMotionControl,
    MotorCommands_SetLimitSpeed,
    MotorCommands_SetLimitCurrent,
    MotorCommands_SetLimitTorque,
    MotorCommands_SetCurrentKp,
    MotorCommands_SetCurrentKi,
    MotorCommands_SetCurrentFilterGain,
    MotorCommands_SetCurrentRef,
    MotorCommands_SetPositionKp,
    MotorCommands_SetPositionRef,
    MotorCommands_SetSpeedKp,
    MotorCommands_SetSpeedKi,
    MotorCommands_SetSpeedRef
  };
  return values;
}

inline const char * const *EnumNamesMotorCommands() {
  static const char * const names[19] = {
    "NONE",
    "InitMotor",
    "EnableMotor",
    "StopMotor",
    "SetRunMode",
    "SendMotionControl",
    "SetLimitSpeed",
    "SetLimitCurrent",
    "SetLimitTorque",
    "SetCurrentKp",
    "SetCurrentKi",
    "SetCurrentFilterGain",
    "SetCurrentRef",
    "SetPositionKp",
    "SetPositionRef",
    "SetSpeedKp",
    "SetSpeedKi",
    "SetSpeedRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameMotorCommands(MotorCommands e) {
  if (::flatbuffers::IsOutRange(e, MotorCommands_NONE, MotorCommands_SetSpeedRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMotorCommands()[index];
}

template<typename T> struct MotorCommandsTraits {
  static const MotorCommands enum_value = MotorCommands_NONE;
};

template<> struct MotorCommandsTraits<MotorControl::InitMotor> {
  static const MotorCommands enum_value = MotorCommands_InitMotor;
};

template<> struct MotorCommandsTraits<MotorControl::EnableMotor> {
  static const MotorCommands enum_value = MotorCommands_EnableMotor;
};

template<> struct MotorCommandsTraits<MotorControl::StopMotor> {
  static const MotorCommands enum_value = MotorCommands_StopMotor;
};

template<> struct MotorCommandsTraits<MotorControl::SetRunMode> {
  static const MotorCommands enum_value = MotorCommands_SetRunMode;
};

template<> struct MotorCommandsTraits<MotorControl::SendMotionControl> {
  static const MotorCommands enum_value = MotorCommands_SendMotionControl;
};

template<> struct MotorCommandsTraits<MotorControl::SetLimitSpeed> {
  static const MotorCommands enum_value = MotorCommands_SetLimitSpeed;
};

template<> struct MotorCommandsTraits<MotorControl::SetLimitCurrent> {
  static const MotorCommands enum_value = MotorCommands_SetLimitCurrent;
};

template<> struct MotorCommandsTraits<MotorControl::SetLimitTorque> {
  static const MotorCommands enum_value = MotorCommands_SetLimitTorque;
};

template<> struct MotorCommandsTraits<MotorControl::SetCurrentKp> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentKp;
};

template<> struct MotorCommandsTraits<MotorControl::SetCurrentKi> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentKi;
};

template<> struct MotorCommandsTraits<MotorControl::SetCurrentFilterGain> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentFilterGain;
};

template<> struct MotorCommandsTraits<MotorControl::SetCurrentRef> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentRef;
};

template<> struct MotorCommandsTraits<MotorControl::SetPositionKp> {
  static const MotorCommands enum_value = MotorCommands_SetPositionKp;
};

template<> struct MotorCommandsTraits<MotorControl::SetPositionRef> {
  static const MotorCommands enum_value = MotorCommands_SetPositionRef;
};

template<> struct MotorCommandsTraits<MotorControl::SetSpeedKp> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedKp;
};

template<> struct MotorCommandsTraits<MotorControl::SetSpeedKi> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedKi;
};

template<> struct MotorCommandsTraits<MotorControl::SetSpeedRef> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedRef;
};

template<typename T> struct MotorCommandsUnionTraits {
  static const MotorCommands enum_value = MotorCommands_NONE;
};

template<> struct MotorCommandsUnionTraits<MotorControl::InitMotorT> {
  static const MotorCommands enum_value = MotorCommands_InitMotor;
};

template<> struct MotorCommandsUnionTraits<MotorControl::EnableMotorT> {
  static const MotorCommands enum_value = MotorCommands_EnableMotor;
};

template<> struct MotorCommandsUnionTraits<MotorControl::StopMotorT> {
  static const MotorCommands enum_value = MotorCommands_StopMotor;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetRunModeT> {
  static const MotorCommands enum_value = MotorCommands_SetRunMode;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SendMotionControlT> {
  static const MotorCommands enum_value = MotorCommands_SendMotionControl;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetLimitSpeedT> {
  static const MotorCommands enum_value = MotorCommands_SetLimitSpeed;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetLimitCurrentT> {
  static const MotorCommands enum_value = MotorCommands_SetLimitCurrent;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetLimitTorqueT> {
  static const MotorCommands enum_value = MotorCommands_SetLimitTorque;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetCurrentKpT> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentKp;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetCurrentKiT> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentKi;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetCurrentFilterGainT> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentFilterGain;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetCurrentRefT> {
  static const MotorCommands enum_value = MotorCommands_SetCurrentRef;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetPositionKpT> {
  static const MotorCommands enum_value = MotorCommands_SetPositionKp;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetPositionRefT> {
  static const MotorCommands enum_value = MotorCommands_SetPositionRef;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetSpeedKpT> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedKp;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetSpeedKiT> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedKi;
};

template<> struct MotorCommandsUnionTraits<MotorControl::SetSpeedRefT> {
  static const MotorCommands enum_value = MotorCommands_SetSpeedRef;
};

struct MotorCommandsUnion {
  MotorCommands type;
  void *value;

  MotorCommandsUnion() : type(MotorCommands_NONE), value(nullptr) {}
  MotorCommandsUnion(MotorCommandsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MotorCommands_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MotorCommandsUnion(const MotorCommandsUnion &);
  MotorCommandsUnion &operator=(const MotorCommandsUnion &u)
    { MotorCommandsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MotorCommandsUnion &operator=(MotorCommandsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MotorCommandsUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = MotorCommandsUnionTraits<RT>::enum_value;
    if (type != MotorCommands_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MotorCommands type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  MotorControl::InitMotorT *AsInitMotor() {
    return type == MotorCommands_InitMotor ?
      reinterpret_cast<MotorControl::InitMotorT *>(value) : nullptr;
  }
  const MotorControl::InitMotorT *AsInitMotor() const {
    return type == MotorCommands_InitMotor ?
      reinterpret_cast<const MotorControl::InitMotorT *>(value) : nullptr;
  }
  MotorControl::EnableMotorT *AsEnableMotor() {
    return type == MotorCommands_EnableMotor ?
      reinterpret_cast<MotorControl::EnableMotorT *>(value) : nullptr;
  }
  const MotorControl::EnableMotorT *AsEnableMotor() const {
    return type == MotorCommands_EnableMotor ?
      reinterpret_cast<const MotorControl::EnableMotorT *>(value) : nullptr;
  }
  MotorControl::StopMotorT *AsStopMotor() {
    return type == MotorCommands_StopMotor ?
      reinterpret_cast<MotorControl::StopMotorT *>(value) : nullptr;
  }
  const MotorControl::StopMotorT *AsStopMotor() const {
    return type == MotorCommands_StopMotor ?
      reinterpret_cast<const MotorControl::StopMotorT *>(value) : nullptr;
  }
  MotorControl::SetRunModeT *AsSetRunMode() {
    return type == MotorCommands_SetRunMode ?
      reinterpret_cast<MotorControl::SetRunModeT *>(value) : nullptr;
  }
  const MotorControl::SetRunModeT *AsSetRunMode() const {
    return type == MotorCommands_SetRunMode ?
      reinterpret_cast<const MotorControl::SetRunModeT *>(value) : nullptr;
  }
  MotorControl::SendMotionControlT *AsSendMotionControl() {
    return type == MotorCommands_SendMotionControl ?
      reinterpret_cast<MotorControl::SendMotionControlT *>(value) : nullptr;
  }
  const MotorControl::SendMotionControlT *AsSendMotionControl() const {
    return type == MotorCommands_SendMotionControl ?
      reinterpret_cast<const MotorControl::SendMotionControlT *>(value) : nullptr;
  }
  MotorControl::SetLimitSpeedT *AsSetLimitSpeed() {
    return type == MotorCommands_SetLimitSpeed ?
      reinterpret_cast<MotorControl::SetLimitSpeedT *>(value) : nullptr;
  }
  const MotorControl::SetLimitSpeedT *AsSetLimitSpeed() const {
    return type == MotorCommands_SetLimitSpeed ?
      reinterpret_cast<const MotorControl::SetLimitSpeedT *>(value) : nullptr;
  }
  MotorControl::SetLimitCurrentT *AsSetLimitCurrent() {
    return type == MotorCommands_SetLimitCurrent ?
      reinterpret_cast<MotorControl::SetLimitCurrentT *>(value) : nullptr;
  }
  const MotorControl::SetLimitCurrentT *AsSetLimitCurrent() const {
    return type == MotorCommands_SetLimitCurrent ?
      reinterpret_cast<const MotorControl::SetLimitCurrentT *>(value) : nullptr;
  }
  MotorControl::SetLimitTorqueT *AsSetLimitTorque() {
    return type == MotorCommands_SetLimitTorque ?
      reinterpret_cast<MotorControl::SetLimitTorqueT *>(value) : nullptr;
  }
  const MotorControl::SetLimitTorqueT *AsSetLimitTorque() const {
    return type == MotorCommands_SetLimitTorque ?
      reinterpret_cast<const MotorControl::SetLimitTorqueT *>(value) : nullptr;
  }
  MotorControl::SetCurrentKpT *AsSetCurrentKp() {
    return type == MotorCommands_SetCurrentKp ?
      reinterpret_cast<MotorControl::SetCurrentKpT *>(value) : nullptr;
  }
  const MotorControl::SetCurrentKpT *AsSetCurrentKp() const {
    return type == MotorCommands_SetCurrentKp ?
      reinterpret_cast<const MotorControl::SetCurrentKpT *>(value) : nullptr;
  }
  MotorControl::SetCurrentKiT *AsSetCurrentKi() {
    return type == MotorCommands_SetCurrentKi ?
      reinterpret_cast<MotorControl::SetCurrentKiT *>(value) : nullptr;
  }
  const MotorControl::SetCurrentKiT *AsSetCurrentKi() const {
    return type == MotorCommands_SetCurrentKi ?
      reinterpret_cast<const MotorControl::SetCurrentKiT *>(value) : nullptr;
  }
  MotorControl::SetCurrentFilterGainT *AsSetCurrentFilterGain() {
    return type == MotorCommands_SetCurrentFilterGain ?
      reinterpret_cast<MotorControl::SetCurrentFilterGainT *>(value) : nullptr;
  }
  const MotorControl::SetCurrentFilterGainT *AsSetCurrentFilterGain() const {
    return type == MotorCommands_SetCurrentFilterGain ?
      reinterpret_cast<const MotorControl::SetCurrentFilterGainT *>(value) : nullptr;
  }
  MotorControl::SetCurrentRefT *AsSetCurrentRef() {
    return type == MotorCommands_SetCurrentRef ?
      reinterpret_cast<MotorControl::SetCurrentRefT *>(value) : nullptr;
  }
  const MotorControl::SetCurrentRefT *AsSetCurrentRef() const {
    return type == MotorCommands_SetCurrentRef ?
      reinterpret_cast<const MotorControl::SetCurrentRefT *>(value) : nullptr;
  }
  MotorControl::SetPositionKpT *AsSetPositionKp() {
    return type == MotorCommands_SetPositionKp ?
      reinterpret_cast<MotorControl::SetPositionKpT *>(value) : nullptr;
  }
  const MotorControl::SetPositionKpT *AsSetPositionKp() const {
    return type == MotorCommands_SetPositionKp ?
      reinterpret_cast<const MotorControl::SetPositionKpT *>(value) : nullptr;
  }
  MotorControl::SetPositionRefT *AsSetPositionRef() {
    return type == MotorCommands_SetPositionRef ?
      reinterpret_cast<MotorControl::SetPositionRefT *>(value) : nullptr;
  }
  const MotorControl::SetPositionRefT *AsSetPositionRef() const {
    return type == MotorCommands_SetPositionRef ?
      reinterpret_cast<const MotorControl::SetPositionRefT *>(value) : nullptr;
  }
  MotorControl::SetSpeedKpT *AsSetSpeedKp() {
    return type == MotorCommands_SetSpeedKp ?
      reinterpret_cast<MotorControl::SetSpeedKpT *>(value) : nullptr;
  }
  const MotorControl::SetSpeedKpT *AsSetSpeedKp() const {
    return type == MotorCommands_SetSpeedKp ?
      reinterpret_cast<const MotorControl::SetSpeedKpT *>(value) : nullptr;
  }
  MotorControl::SetSpeedKiT *AsSetSpeedKi() {
    return type == MotorCommands_SetSpeedKi ?
      reinterpret_cast<MotorControl::SetSpeedKiT *>(value) : nullptr;
  }
  const MotorControl::SetSpeedKiT *AsSetSpeedKi() const {
    return type == MotorCommands_SetSpeedKi ?
      reinterpret_cast<const MotorControl::SetSpeedKiT *>(value) : nullptr;
  }
  MotorControl::SetSpeedRefT *AsSetSpeedRef() {
    return type == MotorCommands_SetSpeedRef ?
      reinterpret_cast<MotorControl::SetSpeedRefT *>(value) : nullptr;
  }
  const MotorControl::SetSpeedRefT *AsSetSpeedRef() const {
    return type == MotorCommands_SetSpeedRef ?
      reinterpret_cast<const MotorControl::SetSpeedRefT *>(value) : nullptr;
  }
};

bool VerifyMotorCommands(::flatbuffers::Verifier &verifier, const void *obj, MotorCommands type);
bool VerifyMotorCommandsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum EncoderCommands : uint8_t {
  EncoderCommands_NONE = 0,
  EncoderCommands_EnableExtendedMode = 1,
  EncoderCommands_StartMotor = 2,
  EncoderCommands_StopMotor = 3,
  EncoderCommands_TorqueControlMode = 4,
  EncoderCommands_SpeedTorqueControlMode = 5,
  EncoderCommands_PositionSpeedTorqueMode = 6,
  EncoderCommands_SetMotorPositionToZero = 7,
  EncoderCommands_MoveMotor = 8,
  EncoderCommands_MIN = EncoderCommands_NONE,
  EncoderCommands_MAX = EncoderCommands_MoveMotor
};

inline const EncoderCommands (&EnumValuesEncoderCommands())[9] {
  static const EncoderCommands values[] = {
    EncoderCommands_NONE,
    EncoderCommands_EnableExtendedMode,
    EncoderCommands_StartMotor,
    EncoderCommands_StopMotor,
    EncoderCommands_TorqueControlMode,
    EncoderCommands_SpeedTorqueControlMode,
    EncoderCommands_PositionSpeedTorqueMode,
    EncoderCommands_SetMotorPositionToZero,
    EncoderCommands_MoveMotor
  };
  return values;
}

inline const char * const *EnumNamesEncoderCommands() {
  static const char * const names[10] = {
    "NONE",
    "EnableExtendedMode",
    "StartMotor",
    "StopMotor",
    "TorqueControlMode",
    "SpeedTorqueControlMode",
    "PositionSpeedTorqueMode",
    "SetMotorPositionToZero",
    "MoveMotor",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncoderCommands(EncoderCommands e) {
  if (::flatbuffers::IsOutRange(e, EncoderCommands_NONE, EncoderCommands_MoveMotor)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncoderCommands()[index];
}

template<typename T> struct EncoderCommandsTraits {
  static const EncoderCommands enum_value = EncoderCommands_NONE;
};

template<> struct EncoderCommandsTraits<MotorControl::EnableExtendedMode> {
  static const EncoderCommands enum_value = EncoderCommands_EnableExtendedMode;
};

template<> struct EncoderCommandsTraits<MotorControl::StartMotor> {
  static const EncoderCommands enum_value = EncoderCommands_StartMotor;
};

template<> struct EncoderCommandsTraits<MotorControl::StopMotor> {
  static const EncoderCommands enum_value = EncoderCommands_StopMotor;
};

template<> struct EncoderCommandsTraits<MotorControl::TorqueControlMode> {
  static const EncoderCommands enum_value = EncoderCommands_TorqueControlMode;
};

template<> struct EncoderCommandsTraits<MotorControl::SpeedTorqueControlMode> {
  static const EncoderCommands enum_value = EncoderCommands_SpeedTorqueControlMode;
};

template<> struct EncoderCommandsTraits<MotorControl::PositionSpeedTorqueMode> {
  static const EncoderCommands enum_value = EncoderCommands_PositionSpeedTorqueMode;
};

template<> struct EncoderCommandsTraits<MotorControl::SetMotorPositionToZero> {
  static const EncoderCommands enum_value = EncoderCommands_SetMotorPositionToZero;
};

template<> struct EncoderCommandsTraits<MotorControl::MoveMotor> {
  static const EncoderCommands enum_value = EncoderCommands_MoveMotor;
};

template<typename T> struct EncoderCommandsUnionTraits {
  static const EncoderCommands enum_value = EncoderCommands_NONE;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::EnableExtendedModeT> {
  static const EncoderCommands enum_value = EncoderCommands_EnableExtendedMode;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::StartMotorT> {
  static const EncoderCommands enum_value = EncoderCommands_StartMotor;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::StopMotorT> {
  static const EncoderCommands enum_value = EncoderCommands_StopMotor;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::TorqueControlModeT> {
  static const EncoderCommands enum_value = EncoderCommands_TorqueControlMode;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::SpeedTorqueControlModeT> {
  static const EncoderCommands enum_value = EncoderCommands_SpeedTorqueControlMode;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::PositionSpeedTorqueModeT> {
  static const EncoderCommands enum_value = EncoderCommands_PositionSpeedTorqueMode;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::SetMotorPositionToZeroT> {
  static const EncoderCommands enum_value = EncoderCommands_SetMotorPositionToZero;
};

template<> struct EncoderCommandsUnionTraits<MotorControl::MoveMotorT> {
  static const EncoderCommands enum_value = EncoderCommands_MoveMotor;
};

struct EncoderCommandsUnion {
  EncoderCommands type;
  void *value;

  EncoderCommandsUnion() : type(EncoderCommands_NONE), value(nullptr) {}
  EncoderCommandsUnion(EncoderCommandsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(EncoderCommands_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EncoderCommandsUnion(const EncoderCommandsUnion &);
  EncoderCommandsUnion &operator=(const EncoderCommandsUnion &u)
    { EncoderCommandsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EncoderCommandsUnion &operator=(EncoderCommandsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EncoderCommandsUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EncoderCommandsUnionTraits<RT>::enum_value;
    if (type != EncoderCommands_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, EncoderCommands type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  MotorControl::EnableExtendedModeT *AsEnableExtendedMode() {
    return type == EncoderCommands_EnableExtendedMode ?
      reinterpret_cast<MotorControl::EnableExtendedModeT *>(value) : nullptr;
  }
  const MotorControl::EnableExtendedModeT *AsEnableExtendedMode() const {
    return type == EncoderCommands_EnableExtendedMode ?
      reinterpret_cast<const MotorControl::EnableExtendedModeT *>(value) : nullptr;
  }
  MotorControl::StartMotorT *AsStartMotor() {
    return type == EncoderCommands_StartMotor ?
      reinterpret_cast<MotorControl::StartMotorT *>(value) : nullptr;
  }
  const MotorControl::StartMotorT *AsStartMotor() const {
    return type == EncoderCommands_StartMotor ?
      reinterpret_cast<const MotorControl::StartMotorT *>(value) : nullptr;
  }
  MotorControl::StopMotorT *AsStopMotor() {
    return type == EncoderCommands_StopMotor ?
      reinterpret_cast<MotorControl::StopMotorT *>(value) : nullptr;
  }
  const MotorControl::StopMotorT *AsStopMotor() const {
    return type == EncoderCommands_StopMotor ?
      reinterpret_cast<const MotorControl::StopMotorT *>(value) : nullptr;
  }
  MotorControl::TorqueControlModeT *AsTorqueControlMode() {
    return type == EncoderCommands_TorqueControlMode ?
      reinterpret_cast<MotorControl::TorqueControlModeT *>(value) : nullptr;
  }
  const MotorControl::TorqueControlModeT *AsTorqueControlMode() const {
    return type == EncoderCommands_TorqueControlMode ?
      reinterpret_cast<const MotorControl::TorqueControlModeT *>(value) : nullptr;
  }
  MotorControl::SpeedTorqueControlModeT *AsSpeedTorqueControlMode() {
    return type == EncoderCommands_SpeedTorqueControlMode ?
      reinterpret_cast<MotorControl::SpeedTorqueControlModeT *>(value) : nullptr;
  }
  const MotorControl::SpeedTorqueControlModeT *AsSpeedTorqueControlMode() const {
    return type == EncoderCommands_SpeedTorqueControlMode ?
      reinterpret_cast<const MotorControl::SpeedTorqueControlModeT *>(value) : nullptr;
  }
  MotorControl::PositionSpeedTorqueModeT *AsPositionSpeedTorqueMode() {
    return type == EncoderCommands_PositionSpeedTorqueMode ?
      reinterpret_cast<MotorControl::PositionSpeedTorqueModeT *>(value) : nullptr;
  }
  const MotorControl::PositionSpeedTorqueModeT *AsPositionSpeedTorqueMode() const {
    return type == EncoderCommands_PositionSpeedTorqueMode ?
      reinterpret_cast<const MotorControl::PositionSpeedTorqueModeT *>(value) : nullptr;
  }
  MotorControl::SetMotorPositionToZeroT *AsSetMotorPositionToZero() {
    return type == EncoderCommands_SetMotorPositionToZero ?
      reinterpret_cast<MotorControl::SetMotorPositionToZeroT *>(value) : nullptr;
  }
  const MotorControl::SetMotorPositionToZeroT *AsSetMotorPositionToZero() const {
    return type == EncoderCommands_SetMotorPositionToZero ?
      reinterpret_cast<const MotorControl::SetMotorPositionToZeroT *>(value) : nullptr;
  }
  MotorControl::MoveMotorT *AsMoveMotor() {
    return type == EncoderCommands_MoveMotor ?
      reinterpret_cast<MotorControl::MoveMotorT *>(value) : nullptr;
  }
  const MotorControl::MoveMotorT *AsMoveMotor() const {
    return type == EncoderCommands_MoveMotor ?
      reinterpret_cast<const MotorControl::MoveMotorT *>(value) : nullptr;
  }
};

bool VerifyEncoderCommands(::flatbuffers::Verifier &verifier, const void *obj, EncoderCommands type);
bool VerifyEncoderCommandsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum CommandType : int8_t {
  CommandType_MOTOR_COMMAND = 0,
  CommandType_ENCODER_COMMAND = 1,
  CommandType_MIN = CommandType_MOTOR_COMMAND,
  CommandType_MAX = CommandType_ENCODER_COMMAND
};

inline const CommandType (&EnumValuesCommandType())[2] {
  static const CommandType values[] = {
    CommandType_MOTOR_COMMAND,
    CommandType_ENCODER_COMMAND
  };
  return values;
}

inline const char * const *EnumNamesCommandType() {
  static const char * const names[3] = {
    "MOTOR_COMMAND",
    "ENCODER_COMMAND",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandType(CommandType e) {
  if (::flatbuffers::IsOutRange(e, CommandType_MOTOR_COMMAND, CommandType_ENCODER_COMMAND)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandType()[index];
}

struct InitMotorT : public ::flatbuffers::NativeTable {
  typedef InitMotor TableType;
  int8_t mode = 0;
};

struct InitMotor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitMotorT NativeTableType;
  typedef InitMotorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  int8_t mode() const {
    return GetField<int8_t>(VT_MODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
  InitMotorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InitMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InitMotor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InitMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InitMotorBuilder {
  typedef InitMotor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(int8_t mode) {
    fbb_.AddElement<int8_t>(InitMotor::VT_MODE, mode, 0);
  }
  explicit InitMotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InitMotor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InitMotor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InitMotor> CreateInitMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t mode = 0) {
  InitMotorBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<InitMotor> CreateInitMotor(::flatbuffers::FlatBufferBuilder &_fbb, const InitMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnableMotorT : public ::flatbuffers::NativeTable {
  typedef EnableMotor TableType;
};

struct EnableMotor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnableMotorT NativeTableType;
  typedef EnableMotorBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EnableMotorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnableMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EnableMotor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnableMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnableMotorBuilder {
  typedef EnableMotor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnableMotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnableMotor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnableMotor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnableMotor> CreateEnableMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnableMotorBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<EnableMotor> CreateEnableMotor(::flatbuffers::FlatBufferBuilder &_fbb, const EnableMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StopMotorT : public ::flatbuffers::NativeTable {
  typedef StopMotor TableType;
};

struct StopMotor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopMotorT NativeTableType;
  typedef StopMotorBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StopMotorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StopMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StopMotor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StopMotorBuilder {
  typedef StopMotor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit StopMotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StopMotor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StopMotor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StopMotor> CreateStopMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  StopMotorBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<StopMotor> CreateStopMotor(::flatbuffers::FlatBufferBuilder &_fbb, const StopMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetRunModeT : public ::flatbuffers::NativeTable {
  typedef SetRunMode TableType;
  int8_t mode = 0;
};

struct SetRunMode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRunModeT NativeTableType;
  typedef SetRunModeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  int8_t mode() const {
    return GetField<int8_t>(VT_MODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
  SetRunModeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetRunModeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetRunMode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetRunModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetRunModeBuilder {
  typedef SetRunMode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(int8_t mode) {
    fbb_.AddElement<int8_t>(SetRunMode::VT_MODE, mode, 0);
  }
  explicit SetRunModeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRunMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRunMode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRunMode> CreateSetRunMode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t mode = 0) {
  SetRunModeBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<SetRunMode> CreateSetRunMode(::flatbuffers::FlatBufferBuilder &_fbb, const SetRunModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SendMotionControlT : public ::flatbuffers::NativeTable {
  typedef SendMotionControl TableType;
  float position = 0.0f;
  float speed = 0.0f;
  float torque = 0.0f;
  float kp = 0.0f;
  float kd = 0.0f;
};

struct SendMotionControl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendMotionControlT NativeTableType;
  typedef SendMotionControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_SPEED = 6,
    VT_TORQUE = 8,
    VT_KP = 10,
    VT_KD = 12
  };
  float position() const {
    return GetField<float>(VT_POSITION, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  float torque() const {
    return GetField<float>(VT_TORQUE, 0.0f);
  }
  float kp() const {
    return GetField<float>(VT_KP, 0.0f);
  }
  float kd() const {
    return GetField<float>(VT_KD, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyField<float>(verifier, VT_TORQUE, 4) &&
           VerifyField<float>(verifier, VT_KP, 4) &&
           VerifyField<float>(verifier, VT_KD, 4) &&
           verifier.EndTable();
  }
  SendMotionControlT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SendMotionControlT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SendMotionControl> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SendMotionControlT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SendMotionControlBuilder {
  typedef SendMotionControl Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(float position) {
    fbb_.AddElement<float>(SendMotionControl::VT_POSITION, position, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(SendMotionControl::VT_SPEED, speed, 0.0f);
  }
  void add_torque(float torque) {
    fbb_.AddElement<float>(SendMotionControl::VT_TORQUE, torque, 0.0f);
  }
  void add_kp(float kp) {
    fbb_.AddElement<float>(SendMotionControl::VT_KP, kp, 0.0f);
  }
  void add_kd(float kd) {
    fbb_.AddElement<float>(SendMotionControl::VT_KD, kd, 0.0f);
  }
  explicit SendMotionControlBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendMotionControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendMotionControl>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SendMotionControl> CreateSendMotionControl(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float position = 0.0f,
    float speed = 0.0f,
    float torque = 0.0f,
    float kp = 0.0f,
    float kd = 0.0f) {
  SendMotionControlBuilder builder_(_fbb);
  builder_.add_kd(kd);
  builder_.add_kp(kp);
  builder_.add_torque(torque);
  builder_.add_speed(speed);
  builder_.add_position(position);
  return builder_.Finish();
}

::flatbuffers::Offset<SendMotionControl> CreateSendMotionControl(::flatbuffers::FlatBufferBuilder &_fbb, const SendMotionControlT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetLimitSpeedT : public ::flatbuffers::NativeTable {
  typedef SetLimitSpeed TableType;
  float speed = 0.0f;
};

struct SetLimitSpeed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLimitSpeedT NativeTableType;
  typedef SetLimitSpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4
  };
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
  SetLimitSpeedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetLimitSpeedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetLimitSpeed> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitSpeedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetLimitSpeedBuilder {
  typedef SetLimitSpeed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed(float speed) {
    fbb_.AddElement<float>(SetLimitSpeed::VT_SPEED, speed, 0.0f);
  }
  explicit SetLimitSpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLimitSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLimitSpeed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLimitSpeed> CreateSetLimitSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float speed = 0.0f) {
  SetLimitSpeedBuilder builder_(_fbb);
  builder_.add_speed(speed);
  return builder_.Finish();
}

::flatbuffers::Offset<SetLimitSpeed> CreateSetLimitSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitSpeedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetLimitCurrentT : public ::flatbuffers::NativeTable {
  typedef SetLimitCurrent TableType;
  float current = 0.0f;
};

struct SetLimitCurrent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLimitCurrentT NativeTableType;
  typedef SetLimitCurrentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT = 4
  };
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           verifier.EndTable();
  }
  SetLimitCurrentT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetLimitCurrentT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetLimitCurrent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitCurrentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetLimitCurrentBuilder {
  typedef SetLimitCurrent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_current(float current) {
    fbb_.AddElement<float>(SetLimitCurrent::VT_CURRENT, current, 0.0f);
  }
  explicit SetLimitCurrentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLimitCurrent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLimitCurrent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLimitCurrent> CreateSetLimitCurrent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float current = 0.0f) {
  SetLimitCurrentBuilder builder_(_fbb);
  builder_.add_current(current);
  return builder_.Finish();
}

::flatbuffers::Offset<SetLimitCurrent> CreateSetLimitCurrent(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitCurrentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetLimitTorqueT : public ::flatbuffers::NativeTable {
  typedef SetLimitTorque TableType;
  float torque = 0.0f;
};

struct SetLimitTorque FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLimitTorqueT NativeTableType;
  typedef SetLimitTorqueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TORQUE = 4
  };
  float torque() const {
    return GetField<float>(VT_TORQUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TORQUE, 4) &&
           verifier.EndTable();
  }
  SetLimitTorqueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetLimitTorqueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetLimitTorque> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitTorqueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetLimitTorqueBuilder {
  typedef SetLimitTorque Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_torque(float torque) {
    fbb_.AddElement<float>(SetLimitTorque::VT_TORQUE, torque, 0.0f);
  }
  explicit SetLimitTorqueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLimitTorque> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLimitTorque>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLimitTorque> CreateSetLimitTorque(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float torque = 0.0f) {
  SetLimitTorqueBuilder builder_(_fbb);
  builder_.add_torque(torque);
  return builder_.Finish();
}

::flatbuffers::Offset<SetLimitTorque> CreateSetLimitTorque(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitTorqueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCurrentKpT : public ::flatbuffers::NativeTable {
  typedef SetCurrentKp TableType;
  float kp = 0.0f;
};

struct SetCurrentKp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCurrentKpT NativeTableType;
  typedef SetCurrentKpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KP = 4
  };
  float kp() const {
    return GetField<float>(VT_KP, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KP, 4) &&
           verifier.EndTable();
  }
  SetCurrentKpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCurrentKpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCurrentKp> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCurrentKpBuilder {
  typedef SetCurrentKp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kp(float kp) {
    fbb_.AddElement<float>(SetCurrentKp::VT_KP, kp, 0.0f);
  }
  explicit SetCurrentKpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCurrentKp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCurrentKp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCurrentKp> CreateSetCurrentKp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float kp = 0.0f) {
  SetCurrentKpBuilder builder_(_fbb);
  builder_.add_kp(kp);
  return builder_.Finish();
}

::flatbuffers::Offset<SetCurrentKp> CreateSetCurrentKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCurrentKiT : public ::flatbuffers::NativeTable {
  typedef SetCurrentKi TableType;
  float ki = 0.0f;
};

struct SetCurrentKi FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCurrentKiT NativeTableType;
  typedef SetCurrentKiBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KI = 4
  };
  float ki() const {
    return GetField<float>(VT_KI, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KI, 4) &&
           verifier.EndTable();
  }
  SetCurrentKiT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCurrentKiT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCurrentKi> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCurrentKiBuilder {
  typedef SetCurrentKi Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ki(float ki) {
    fbb_.AddElement<float>(SetCurrentKi::VT_KI, ki, 0.0f);
  }
  explicit SetCurrentKiBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCurrentKi> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCurrentKi>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCurrentKi> CreateSetCurrentKi(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float ki = 0.0f) {
  SetCurrentKiBuilder builder_(_fbb);
  builder_.add_ki(ki);
  return builder_.Finish();
}

::flatbuffers::Offset<SetCurrentKi> CreateSetCurrentKi(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCurrentFilterGainT : public ::flatbuffers::NativeTable {
  typedef SetCurrentFilterGain TableType;
  float gain = 0.0f;
};

struct SetCurrentFilterGain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCurrentFilterGainT NativeTableType;
  typedef SetCurrentFilterGainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GAIN = 4
  };
  float gain() const {
    return GetField<float>(VT_GAIN, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GAIN, 4) &&
           verifier.EndTable();
  }
  SetCurrentFilterGainT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCurrentFilterGainT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCurrentFilterGain> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentFilterGainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCurrentFilterGainBuilder {
  typedef SetCurrentFilterGain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gain(float gain) {
    fbb_.AddElement<float>(SetCurrentFilterGain::VT_GAIN, gain, 0.0f);
  }
  explicit SetCurrentFilterGainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCurrentFilterGain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCurrentFilterGain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCurrentFilterGain> CreateSetCurrentFilterGain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float gain = 0.0f) {
  SetCurrentFilterGainBuilder builder_(_fbb);
  builder_.add_gain(gain);
  return builder_.Finish();
}

::flatbuffers::Offset<SetCurrentFilterGain> CreateSetCurrentFilterGain(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentFilterGainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCurrentRefT : public ::flatbuffers::NativeTable {
  typedef SetCurrentRef TableType;
  float current_ref = 0.0f;
};

struct SetCurrentRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCurrentRefT NativeTableType;
  typedef SetCurrentRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_REF = 4
  };
  float current_ref() const {
    return GetField<float>(VT_CURRENT_REF, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CURRENT_REF, 4) &&
           verifier.EndTable();
  }
  SetCurrentRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCurrentRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCurrentRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCurrentRefBuilder {
  typedef SetCurrentRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_current_ref(float current_ref) {
    fbb_.AddElement<float>(SetCurrentRef::VT_CURRENT_REF, current_ref, 0.0f);
  }
  explicit SetCurrentRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCurrentRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCurrentRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCurrentRef> CreateSetCurrentRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float current_ref = 0.0f) {
  SetCurrentRefBuilder builder_(_fbb);
  builder_.add_current_ref(current_ref);
  return builder_.Finish();
}

::flatbuffers::Offset<SetCurrentRef> CreateSetCurrentRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetPositionKpT : public ::flatbuffers::NativeTable {
  typedef SetPositionKp TableType;
  float kp = 0.0f;
};

struct SetPositionKp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetPositionKpT NativeTableType;
  typedef SetPositionKpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KP = 4
  };
  float kp() const {
    return GetField<float>(VT_KP, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KP, 4) &&
           verifier.EndTable();
  }
  SetPositionKpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetPositionKpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetPositionKp> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetPositionKpBuilder {
  typedef SetPositionKp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kp(float kp) {
    fbb_.AddElement<float>(SetPositionKp::VT_KP, kp, 0.0f);
  }
  explicit SetPositionKpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetPositionKp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetPositionKp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetPositionKp> CreateSetPositionKp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float kp = 0.0f) {
  SetPositionKpBuilder builder_(_fbb);
  builder_.add_kp(kp);
  return builder_.Finish();
}

::flatbuffers::Offset<SetPositionKp> CreateSetPositionKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetPositionRefT : public ::flatbuffers::NativeTable {
  typedef SetPositionRef TableType;
  float position_ref = 0.0f;
};

struct SetPositionRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetPositionRefT NativeTableType;
  typedef SetPositionRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_REF = 4
  };
  float position_ref() const {
    return GetField<float>(VT_POSITION_REF, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POSITION_REF, 4) &&
           verifier.EndTable();
  }
  SetPositionRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetPositionRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetPositionRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetPositionRefBuilder {
  typedef SetPositionRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position_ref(float position_ref) {
    fbb_.AddElement<float>(SetPositionRef::VT_POSITION_REF, position_ref, 0.0f);
  }
  explicit SetPositionRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetPositionRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetPositionRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetPositionRef> CreateSetPositionRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float position_ref = 0.0f) {
  SetPositionRefBuilder builder_(_fbb);
  builder_.add_position_ref(position_ref);
  return builder_.Finish();
}

::flatbuffers::Offset<SetPositionRef> CreateSetPositionRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetSpeedKpT : public ::flatbuffers::NativeTable {
  typedef SetSpeedKp TableType;
  float kp = 0.0f;
};

struct SetSpeedKp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetSpeedKpT NativeTableType;
  typedef SetSpeedKpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KP = 4
  };
  float kp() const {
    return GetField<float>(VT_KP, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KP, 4) &&
           verifier.EndTable();
  }
  SetSpeedKpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetSpeedKpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetSpeedKp> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetSpeedKpBuilder {
  typedef SetSpeedKp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kp(float kp) {
    fbb_.AddElement<float>(SetSpeedKp::VT_KP, kp, 0.0f);
  }
  explicit SetSpeedKpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetSpeedKp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetSpeedKp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetSpeedKp> CreateSetSpeedKp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float kp = 0.0f) {
  SetSpeedKpBuilder builder_(_fbb);
  builder_.add_kp(kp);
  return builder_.Finish();
}

::flatbuffers::Offset<SetSpeedKp> CreateSetSpeedKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetSpeedKiT : public ::flatbuffers::NativeTable {
  typedef SetSpeedKi TableType;
  float ki = 0.0f;
};

struct SetSpeedKi FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetSpeedKiT NativeTableType;
  typedef SetSpeedKiBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KI = 4
  };
  float ki() const {
    return GetField<float>(VT_KI, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KI, 4) &&
           verifier.EndTable();
  }
  SetSpeedKiT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetSpeedKiT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetSpeedKi> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetSpeedKiBuilder {
  typedef SetSpeedKi Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ki(float ki) {
    fbb_.AddElement<float>(SetSpeedKi::VT_KI, ki, 0.0f);
  }
  explicit SetSpeedKiBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetSpeedKi> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetSpeedKi>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetSpeedKi> CreateSetSpeedKi(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float ki = 0.0f) {
  SetSpeedKiBuilder builder_(_fbb);
  builder_.add_ki(ki);
  return builder_.Finish();
}

::flatbuffers::Offset<SetSpeedKi> CreateSetSpeedKi(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetSpeedRefT : public ::flatbuffers::NativeTable {
  typedef SetSpeedRef TableType;
  float speed_ref = 0.0f;
};

struct SetSpeedRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetSpeedRefT NativeTableType;
  typedef SetSpeedRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED_REF = 4
  };
  float speed_ref() const {
    return GetField<float>(VT_SPEED_REF, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SPEED_REF, 4) &&
           verifier.EndTable();
  }
  SetSpeedRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetSpeedRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetSpeedRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetSpeedRefBuilder {
  typedef SetSpeedRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed_ref(float speed_ref) {
    fbb_.AddElement<float>(SetSpeedRef::VT_SPEED_REF, speed_ref, 0.0f);
  }
  explicit SetSpeedRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetSpeedRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetSpeedRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetSpeedRef> CreateSetSpeedRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float speed_ref = 0.0f) {
  SetSpeedRefBuilder builder_(_fbb);
  builder_.add_speed_ref(speed_ref);
  return builder_.Finish();
}

::flatbuffers::Offset<SetSpeedRef> CreateSetSpeedRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotorCommandT : public ::flatbuffers::NativeTable {
  typedef MotorCommand TableType;
  int8_t motor_id = 0;
  MotorControl::MotorCommandsUnion command{};
};

struct MotorCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorCommandT NativeTableType;
  typedef MotorCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOTOR_ID = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8
  };
  int8_t motor_id() const {
    return GetField<int8_t>(VT_MOTOR_ID, 0);
  }
  MotorControl::MotorCommands command_type() const {
    return static_cast<MotorControl::MotorCommands>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const MotorControl::InitMotor *command_as_InitMotor() const {
    return command_type() == MotorControl::MotorCommands_InitMotor ? static_cast<const MotorControl::InitMotor *>(command()) : nullptr;
  }
  const MotorControl::EnableMotor *command_as_EnableMotor() const {
    return command_type() == MotorControl::MotorCommands_EnableMotor ? static_cast<const MotorControl::EnableMotor *>(command()) : nullptr;
  }
  const MotorControl::StopMotor *command_as_StopMotor() const {
    return command_type() == MotorControl::MotorCommands_StopMotor ? static_cast<const MotorControl::StopMotor *>(command()) : nullptr;
  }
  const MotorControl::SetRunMode *command_as_SetRunMode() const {
    return command_type() == MotorControl::MotorCommands_SetRunMode ? static_cast<const MotorControl::SetRunMode *>(command()) : nullptr;
  }
  const MotorControl::SendMotionControl *command_as_SendMotionControl() const {
    return command_type() == MotorControl::MotorCommands_SendMotionControl ? static_cast<const MotorControl::SendMotionControl *>(command()) : nullptr;
  }
  const MotorControl::SetLimitSpeed *command_as_SetLimitSpeed() const {
    return command_type() == MotorControl::MotorCommands_SetLimitSpeed ? static_cast<const MotorControl::SetLimitSpeed *>(command()) : nullptr;
  }
  const MotorControl::SetLimitCurrent *command_as_SetLimitCurrent() const {
    return command_type() == MotorControl::MotorCommands_SetLimitCurrent ? static_cast<const MotorControl::SetLimitCurrent *>(command()) : nullptr;
  }
  const MotorControl::SetLimitTorque *command_as_SetLimitTorque() const {
    return command_type() == MotorControl::MotorCommands_SetLimitTorque ? static_cast<const MotorControl::SetLimitTorque *>(command()) : nullptr;
  }
  const MotorControl::SetCurrentKp *command_as_SetCurrentKp() const {
    return command_type() == MotorControl::MotorCommands_SetCurrentKp ? static_cast<const MotorControl::SetCurrentKp *>(command()) : nullptr;
  }
  const MotorControl::SetCurrentKi *command_as_SetCurrentKi() const {
    return command_type() == MotorControl::MotorCommands_SetCurrentKi ? static_cast<const MotorControl::SetCurrentKi *>(command()) : nullptr;
  }
  const MotorControl::SetCurrentFilterGain *command_as_SetCurrentFilterGain() const {
    return command_type() == MotorControl::MotorCommands_SetCurrentFilterGain ? static_cast<const MotorControl::SetCurrentFilterGain *>(command()) : nullptr;
  }
  const MotorControl::SetCurrentRef *command_as_SetCurrentRef() const {
    return command_type() == MotorControl::MotorCommands_SetCurrentRef ? static_cast<const MotorControl::SetCurrentRef *>(command()) : nullptr;
  }
  const MotorControl::SetPositionKp *command_as_SetPositionKp() const {
    return command_type() == MotorControl::MotorCommands_SetPositionKp ? static_cast<const MotorControl::SetPositionKp *>(command()) : nullptr;
  }
  const MotorControl::SetPositionRef *command_as_SetPositionRef() const {
    return command_type() == MotorControl::MotorCommands_SetPositionRef ? static_cast<const MotorControl::SetPositionRef *>(command()) : nullptr;
  }
  const MotorControl::SetSpeedKp *command_as_SetSpeedKp() const {
    return command_type() == MotorControl::MotorCommands_SetSpeedKp ? static_cast<const MotorControl::SetSpeedKp *>(command()) : nullptr;
  }
  const MotorControl::SetSpeedKi *command_as_SetSpeedKi() const {
    return command_type() == MotorControl::MotorCommands_SetSpeedKi ? static_cast<const MotorControl::SetSpeedKi *>(command()) : nullptr;
  }
  const MotorControl::SetSpeedRef *command_as_SetSpeedRef() const {
    return command_type() == MotorControl::MotorCommands_SetSpeedRef ? static_cast<const MotorControl::SetSpeedRef *>(command()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MOTOR_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyMotorCommands(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  MotorCommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotorCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MotorCommand> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MotorCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const MotorControl::InitMotor *MotorCommand::command_as<MotorControl::InitMotor>() const {
  return command_as_InitMotor();
}

template<> inline const MotorControl::EnableMotor *MotorCommand::command_as<MotorControl::EnableMotor>() const {
  return command_as_EnableMotor();
}

template<> inline const MotorControl::StopMotor *MotorCommand::command_as<MotorControl::StopMotor>() const {
  return command_as_StopMotor();
}

template<> inline const MotorControl::SetRunMode *MotorCommand::command_as<MotorControl::SetRunMode>() const {
  return command_as_SetRunMode();
}

template<> inline const MotorControl::SendMotionControl *MotorCommand::command_as<MotorControl::SendMotionControl>() const {
  return command_as_SendMotionControl();
}

template<> inline const MotorControl::SetLimitSpeed *MotorCommand::command_as<MotorControl::SetLimitSpeed>() const {
  return command_as_SetLimitSpeed();
}

template<> inline const MotorControl::SetLimitCurrent *MotorCommand::command_as<MotorControl::SetLimitCurrent>() const {
  return command_as_SetLimitCurrent();
}

template<> inline const MotorControl::SetLimitTorque *MotorCommand::command_as<MotorControl::SetLimitTorque>() const {
  return command_as_SetLimitTorque();
}

template<> inline const MotorControl::SetCurrentKp *MotorCommand::command_as<MotorControl::SetCurrentKp>() const {
  return command_as_SetCurrentKp();
}

template<> inline const MotorControl::SetCurrentKi *MotorCommand::command_as<MotorControl::SetCurrentKi>() const {
  return command_as_SetCurrentKi();
}

template<> inline const MotorControl::SetCurrentFilterGain *MotorCommand::command_as<MotorControl::SetCurrentFilterGain>() const {
  return command_as_SetCurrentFilterGain();
}

template<> inline const MotorControl::SetCurrentRef *MotorCommand::command_as<MotorControl::SetCurrentRef>() const {
  return command_as_SetCurrentRef();
}

template<> inline const MotorControl::SetPositionKp *MotorCommand::command_as<MotorControl::SetPositionKp>() const {
  return command_as_SetPositionKp();
}

template<> inline const MotorControl::SetPositionRef *MotorCommand::command_as<MotorControl::SetPositionRef>() const {
  return command_as_SetPositionRef();
}

template<> inline const MotorControl::SetSpeedKp *MotorCommand::command_as<MotorControl::SetSpeedKp>() const {
  return command_as_SetSpeedKp();
}

template<> inline const MotorControl::SetSpeedKi *MotorCommand::command_as<MotorControl::SetSpeedKi>() const {
  return command_as_SetSpeedKi();
}

template<> inline const MotorControl::SetSpeedRef *MotorCommand::command_as<MotorControl::SetSpeedRef>() const {
  return command_as_SetSpeedRef();
}

struct MotorCommandBuilder {
  typedef MotorCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_motor_id(int8_t motor_id) {
    fbb_.AddElement<int8_t>(MotorCommand::VT_MOTOR_ID, motor_id, 0);
  }
  void add_command_type(MotorControl::MotorCommands command_type) {
    fbb_.AddElement<uint8_t>(MotorCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(MotorCommand::VT_COMMAND, command);
  }
  explicit MotorCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MotorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MotorCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MotorCommand> CreateMotorCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t motor_id = 0,
    MotorControl::MotorCommands command_type = MotorControl::MotorCommands_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  MotorCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  builder_.add_motor_id(motor_id);
  return builder_.Finish();
}

::flatbuffers::Offset<MotorCommand> CreateMotorCommand(::flatbuffers::FlatBufferBuilder &_fbb, const MotorCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnableExtendedModeT : public ::flatbuffers::NativeTable {
  typedef EnableExtendedMode TableType;
};

struct EnableExtendedMode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnableExtendedModeT NativeTableType;
  typedef EnableExtendedModeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EnableExtendedModeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnableExtendedModeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EnableExtendedMode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnableExtendedModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnableExtendedModeBuilder {
  typedef EnableExtendedMode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EnableExtendedModeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnableExtendedMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnableExtendedMode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnableExtendedMode> CreateEnableExtendedMode(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EnableExtendedModeBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<EnableExtendedMode> CreateEnableExtendedMode(::flatbuffers::FlatBufferBuilder &_fbb, const EnableExtendedModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartMotorT : public ::flatbuffers::NativeTable {
  typedef StartMotor TableType;
};

struct StartMotor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartMotorT NativeTableType;
  typedef StartMotorBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StartMotorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartMotor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartMotorBuilder {
  typedef StartMotor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit StartMotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartMotor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartMotor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartMotor> CreateStartMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  StartMotorBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<StartMotor> CreateStartMotor(::flatbuffers::FlatBufferBuilder &_fbb, const StartMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TorqueControlModeT : public ::flatbuffers::NativeTable {
  typedef TorqueControlMode TableType;
};

struct TorqueControlMode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TorqueControlModeT NativeTableType;
  typedef TorqueControlModeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TorqueControlModeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TorqueControlModeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TorqueControlMode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TorqueControlModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TorqueControlModeBuilder {
  typedef TorqueControlMode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TorqueControlModeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TorqueControlMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TorqueControlMode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TorqueControlMode> CreateTorqueControlMode(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TorqueControlModeBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<TorqueControlMode> CreateTorqueControlMode(::flatbuffers::FlatBufferBuilder &_fbb, const TorqueControlModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpeedTorqueControlModeT : public ::flatbuffers::NativeTable {
  typedef SpeedTorqueControlMode TableType;
};

struct SpeedTorqueControlMode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpeedTorqueControlModeT NativeTableType;
  typedef SpeedTorqueControlModeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpeedTorqueControlModeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpeedTorqueControlModeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpeedTorqueControlMode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpeedTorqueControlModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpeedTorqueControlModeBuilder {
  typedef SpeedTorqueControlMode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SpeedTorqueControlModeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpeedTorqueControlMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpeedTorqueControlMode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpeedTorqueControlMode> CreateSpeedTorqueControlMode(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SpeedTorqueControlModeBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SpeedTorqueControlMode> CreateSpeedTorqueControlMode(::flatbuffers::FlatBufferBuilder &_fbb, const SpeedTorqueControlModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PositionSpeedTorqueModeT : public ::flatbuffers::NativeTable {
  typedef PositionSpeedTorqueMode TableType;
};

struct PositionSpeedTorqueMode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionSpeedTorqueModeT NativeTableType;
  typedef PositionSpeedTorqueModeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PositionSpeedTorqueModeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PositionSpeedTorqueModeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PositionSpeedTorqueMode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PositionSpeedTorqueModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PositionSpeedTorqueModeBuilder {
  typedef PositionSpeedTorqueMode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PositionSpeedTorqueModeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionSpeedTorqueMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionSpeedTorqueMode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionSpeedTorqueMode> CreatePositionSpeedTorqueMode(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PositionSpeedTorqueModeBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PositionSpeedTorqueMode> CreatePositionSpeedTorqueMode(::flatbuffers::FlatBufferBuilder &_fbb, const PositionSpeedTorqueModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetMotorPositionToZeroT : public ::flatbuffers::NativeTable {
  typedef SetMotorPositionToZero TableType;
};

struct SetMotorPositionToZero FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMotorPositionToZeroT NativeTableType;
  typedef SetMotorPositionToZeroBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SetMotorPositionToZeroT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetMotorPositionToZeroT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetMotorPositionToZero> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMotorPositionToZeroT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetMotorPositionToZeroBuilder {
  typedef SetMotorPositionToZero Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SetMotorPositionToZeroBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMotorPositionToZero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMotorPositionToZero>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMotorPositionToZero> CreateSetMotorPositionToZero(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SetMotorPositionToZeroBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SetMotorPositionToZero> CreateSetMotorPositionToZero(::flatbuffers::FlatBufferBuilder &_fbb, const SetMotorPositionToZeroT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveMotorT : public ::flatbuffers::NativeTable {
  typedef MoveMotor TableType;
  int16_t position_degrees = 0;
  int16_t speed = 0;
  uint16_t position_gain = 0;
  uint16_t position_damping = 0;
  uint16_t torque = 0;
};

struct MoveMotor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveMotorT NativeTableType;
  typedef MoveMotorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_DEGREES = 4,
    VT_SPEED = 6,
    VT_POSITION_GAIN = 8,
    VT_POSITION_DAMPING = 10,
    VT_TORQUE = 12
  };
  int16_t position_degrees() const {
    return GetField<int16_t>(VT_POSITION_DEGREES, 0);
  }
  int16_t speed() const {
    return GetField<int16_t>(VT_SPEED, 0);
  }
  uint16_t position_gain() const {
    return GetField<uint16_t>(VT_POSITION_GAIN, 0);
  }
  uint16_t position_damping() const {
    return GetField<uint16_t>(VT_POSITION_DAMPING, 0);
  }
  uint16_t torque() const {
    return GetField<uint16_t>(VT_TORQUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_POSITION_DEGREES, 2) &&
           VerifyField<int16_t>(verifier, VT_SPEED, 2) &&
           VerifyField<uint16_t>(verifier, VT_POSITION_GAIN, 2) &&
           VerifyField<uint16_t>(verifier, VT_POSITION_DAMPING, 2) &&
           VerifyField<uint16_t>(verifier, VT_TORQUE, 2) &&
           verifier.EndTable();
  }
  MoveMotorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MoveMotor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveMotorBuilder {
  typedef MoveMotor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position_degrees(int16_t position_degrees) {
    fbb_.AddElement<int16_t>(MoveMotor::VT_POSITION_DEGREES, position_degrees, 0);
  }
  void add_speed(int16_t speed) {
    fbb_.AddElement<int16_t>(MoveMotor::VT_SPEED, speed, 0);
  }
  void add_position_gain(uint16_t position_gain) {
    fbb_.AddElement<uint16_t>(MoveMotor::VT_POSITION_GAIN, position_gain, 0);
  }
  void add_position_damping(uint16_t position_damping) {
    fbb_.AddElement<uint16_t>(MoveMotor::VT_POSITION_DAMPING, position_damping, 0);
  }
  void add_torque(uint16_t torque) {
    fbb_.AddElement<uint16_t>(MoveMotor::VT_TORQUE, torque, 0);
  }
  explicit MoveMotorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveMotor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveMotor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveMotor> CreateMoveMotor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t position_degrees = 0,
    int16_t speed = 0,
    uint16_t position_gain = 0,
    uint16_t position_damping = 0,
    uint16_t torque = 0) {
  MoveMotorBuilder builder_(_fbb);
  builder_.add_torque(torque);
  builder_.add_position_damping(position_damping);
  builder_.add_position_gain(position_gain);
  builder_.add_speed(speed);
  builder_.add_position_degrees(position_degrees);
  return builder_.Finish();
}

::flatbuffers::Offset<MoveMotor> CreateMoveMotor(::flatbuffers::FlatBufferBuilder &_fbb, const MoveMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EncoderCommandT : public ::flatbuffers::NativeTable {
  typedef EncoderCommand TableType;
  int8_t motor_id = 0;
  MotorControl::EncoderCommandsUnion command{};
};

struct EncoderCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncoderCommandT NativeTableType;
  typedef EncoderCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOTOR_ID = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8
  };
  int8_t motor_id() const {
    return GetField<int8_t>(VT_MOTOR_ID, 0);
  }
  MotorControl::EncoderCommands command_type() const {
    return static_cast<MotorControl::EncoderCommands>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const MotorControl::EnableExtendedMode *command_as_EnableExtendedMode() const {
    return command_type() == MotorControl::EncoderCommands_EnableExtendedMode ? static_cast<const MotorControl::EnableExtendedMode *>(command()) : nullptr;
  }
  const MotorControl::StartMotor *command_as_StartMotor() const {
    return command_type() == MotorControl::EncoderCommands_StartMotor ? static_cast<const MotorControl::StartMotor *>(command()) : nullptr;
  }
  const MotorControl::StopMotor *command_as_StopMotor() const {
    return command_type() == MotorControl::EncoderCommands_StopMotor ? static_cast<const MotorControl::StopMotor *>(command()) : nullptr;
  }
  const MotorControl::TorqueControlMode *command_as_TorqueControlMode() const {
    return command_type() == MotorControl::EncoderCommands_TorqueControlMode ? static_cast<const MotorControl::TorqueControlMode *>(command()) : nullptr;
  }
  const MotorControl::SpeedTorqueControlMode *command_as_SpeedTorqueControlMode() const {
    return command_type() == MotorControl::EncoderCommands_SpeedTorqueControlMode ? static_cast<const MotorControl::SpeedTorqueControlMode *>(command()) : nullptr;
  }
  const MotorControl::PositionSpeedTorqueMode *command_as_PositionSpeedTorqueMode() const {
    return command_type() == MotorControl::EncoderCommands_PositionSpeedTorqueMode ? static_cast<const MotorControl::PositionSpeedTorqueMode *>(command()) : nullptr;
  }
  const MotorControl::SetMotorPositionToZero *command_as_SetMotorPositionToZero() const {
    return command_type() == MotorControl::EncoderCommands_SetMotorPositionToZero ? static_cast<const MotorControl::SetMotorPositionToZero *>(command()) : nullptr;
  }
  const MotorControl::MoveMotor *command_as_MoveMotor() const {
    return command_type() == MotorControl::EncoderCommands_MoveMotor ? static_cast<const MotorControl::MoveMotor *>(command()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MOTOR_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyEncoderCommands(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  EncoderCommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EncoderCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EncoderCommand> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EncoderCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const MotorControl::EnableExtendedMode *EncoderCommand::command_as<MotorControl::EnableExtendedMode>() const {
  return command_as_EnableExtendedMode();
}

template<> inline const MotorControl::StartMotor *EncoderCommand::command_as<MotorControl::StartMotor>() const {
  return command_as_StartMotor();
}

template<> inline const MotorControl::StopMotor *EncoderCommand::command_as<MotorControl::StopMotor>() const {
  return command_as_StopMotor();
}

template<> inline const MotorControl::TorqueControlMode *EncoderCommand::command_as<MotorControl::TorqueControlMode>() const {
  return command_as_TorqueControlMode();
}

template<> inline const MotorControl::SpeedTorqueControlMode *EncoderCommand::command_as<MotorControl::SpeedTorqueControlMode>() const {
  return command_as_SpeedTorqueControlMode();
}

template<> inline const MotorControl::PositionSpeedTorqueMode *EncoderCommand::command_as<MotorControl::PositionSpeedTorqueMode>() const {
  return command_as_PositionSpeedTorqueMode();
}

template<> inline const MotorControl::SetMotorPositionToZero *EncoderCommand::command_as<MotorControl::SetMotorPositionToZero>() const {
  return command_as_SetMotorPositionToZero();
}

template<> inline const MotorControl::MoveMotor *EncoderCommand::command_as<MotorControl::MoveMotor>() const {
  return command_as_MoveMotor();
}

struct EncoderCommandBuilder {
  typedef EncoderCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_motor_id(int8_t motor_id) {
    fbb_.AddElement<int8_t>(EncoderCommand::VT_MOTOR_ID, motor_id, 0);
  }
  void add_command_type(MotorControl::EncoderCommands command_type) {
    fbb_.AddElement<uint8_t>(EncoderCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(EncoderCommand::VT_COMMAND, command);
  }
  explicit EncoderCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncoderCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncoderCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncoderCommand> CreateEncoderCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t motor_id = 0,
    MotorControl::EncoderCommands command_type = MotorControl::EncoderCommands_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  EncoderCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  builder_.add_motor_id(motor_id);
  return builder_.Finish();
}

::flatbuffers::Offset<EncoderCommand> CreateEncoderCommand(::flatbuffers::FlatBufferBuilder &_fbb, const EncoderCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  MotorControl::CommandType type = MotorControl::CommandType_MOTOR_COMMAND;
  std::unique_ptr<MotorControl::MotorCommandT> motor_control{};
  std::unique_ptr<MotorControl::EncoderCommandT> encoder_control{};
  CommandT() = default;
  CommandT(const CommandT &o);
  CommandT(CommandT&&) FLATBUFFERS_NOEXCEPT = default;
  CommandT &operator=(CommandT o) FLATBUFFERS_NOEXCEPT;
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_MOTOR_CONTROL = 6,
    VT_ENCODER_CONTROL = 8
  };
  MotorControl::CommandType type() const {
    return static_cast<MotorControl::CommandType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const MotorControl::MotorCommand *motor_control() const {
    return GetPointer<const MotorControl::MotorCommand *>(VT_MOTOR_CONTROL);
  }
  const MotorControl::EncoderCommand *encoder_control() const {
    return GetPointer<const MotorControl::EncoderCommand *>(VT_ENCODER_CONTROL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_MOTOR_CONTROL) &&
           verifier.VerifyTable(motor_control()) &&
           VerifyOffset(verifier, VT_ENCODER_CONTROL) &&
           verifier.VerifyTable(encoder_control()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MotorControl::CommandType type) {
    fbb_.AddElement<int8_t>(Command::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_motor_control(::flatbuffers::Offset<MotorControl::MotorCommand> motor_control) {
    fbb_.AddOffset(Command::VT_MOTOR_CONTROL, motor_control);
  }
  void add_encoder_control(::flatbuffers::Offset<MotorControl::EncoderCommand> encoder_control) {
    fbb_.AddOffset(Command::VT_ENCODER_CONTROL, encoder_control);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MotorControl::CommandType type = MotorControl::CommandType_MOTOR_COMMAND,
    ::flatbuffers::Offset<MotorControl::MotorCommand> motor_control = 0,
    ::flatbuffers::Offset<MotorControl::EncoderCommand> encoder_control = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_encoder_control(encoder_control);
  builder_.add_motor_control(motor_control);
  builder_.add_type(type);
  return builder_.Finish();
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InitMotorT *InitMotor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InitMotorT>(new InitMotorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InitMotor::UnPackTo(InitMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline ::flatbuffers::Offset<InitMotor> InitMotor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InitMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInitMotor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InitMotor> CreateInitMotor(::flatbuffers::FlatBufferBuilder &_fbb, const InitMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InitMotorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return MotorControl::CreateInitMotor(
      _fbb,
      _mode);
}

inline EnableMotorT *EnableMotor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnableMotorT>(new EnableMotorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnableMotor::UnPackTo(EnableMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<EnableMotor> EnableMotor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnableMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnableMotor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EnableMotor> CreateEnableMotor(::flatbuffers::FlatBufferBuilder &_fbb, const EnableMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnableMotorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateEnableMotor(
      _fbb);
}

inline StopMotorT *StopMotor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StopMotorT>(new StopMotorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StopMotor::UnPackTo(StopMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<StopMotor> StopMotor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStopMotor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StopMotor> CreateStopMotor(::flatbuffers::FlatBufferBuilder &_fbb, const StopMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StopMotorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateStopMotor(
      _fbb);
}

inline SetRunModeT *SetRunMode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetRunModeT>(new SetRunModeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetRunMode::UnPackTo(SetRunModeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline ::flatbuffers::Offset<SetRunMode> SetRunMode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetRunModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetRunMode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetRunMode> CreateSetRunMode(::flatbuffers::FlatBufferBuilder &_fbb, const SetRunModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetRunModeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return MotorControl::CreateSetRunMode(
      _fbb,
      _mode);
}

inline SendMotionControlT *SendMotionControl::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SendMotionControlT>(new SendMotionControlT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SendMotionControl::UnPackTo(SendMotionControlT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); _o->position = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = torque(); _o->torque = _e; }
  { auto _e = kp(); _o->kp = _e; }
  { auto _e = kd(); _o->kd = _e; }
}

inline ::flatbuffers::Offset<SendMotionControl> SendMotionControl::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SendMotionControlT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSendMotionControl(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SendMotionControl> CreateSendMotionControl(::flatbuffers::FlatBufferBuilder &_fbb, const SendMotionControlT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SendMotionControlT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position;
  auto _speed = _o->speed;
  auto _torque = _o->torque;
  auto _kp = _o->kp;
  auto _kd = _o->kd;
  return MotorControl::CreateSendMotionControl(
      _fbb,
      _position,
      _speed,
      _torque,
      _kp,
      _kd);
}

inline SetLimitSpeedT *SetLimitSpeed::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetLimitSpeedT>(new SetLimitSpeedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetLimitSpeed::UnPackTo(SetLimitSpeedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = speed(); _o->speed = _e; }
}

inline ::flatbuffers::Offset<SetLimitSpeed> SetLimitSpeed::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitSpeedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetLimitSpeed(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetLimitSpeed> CreateSetLimitSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitSpeedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetLimitSpeedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _speed = _o->speed;
  return MotorControl::CreateSetLimitSpeed(
      _fbb,
      _speed);
}

inline SetLimitCurrentT *SetLimitCurrent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetLimitCurrentT>(new SetLimitCurrentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetLimitCurrent::UnPackTo(SetLimitCurrentT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = current(); _o->current = _e; }
}

inline ::flatbuffers::Offset<SetLimitCurrent> SetLimitCurrent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitCurrentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetLimitCurrent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetLimitCurrent> CreateSetLimitCurrent(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitCurrentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetLimitCurrentT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _current = _o->current;
  return MotorControl::CreateSetLimitCurrent(
      _fbb,
      _current);
}

inline SetLimitTorqueT *SetLimitTorque::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetLimitTorqueT>(new SetLimitTorqueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetLimitTorque::UnPackTo(SetLimitTorqueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = torque(); _o->torque = _e; }
}

inline ::flatbuffers::Offset<SetLimitTorque> SetLimitTorque::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitTorqueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetLimitTorque(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetLimitTorque> CreateSetLimitTorque(::flatbuffers::FlatBufferBuilder &_fbb, const SetLimitTorqueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetLimitTorqueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _torque = _o->torque;
  return MotorControl::CreateSetLimitTorque(
      _fbb,
      _torque);
}

inline SetCurrentKpT *SetCurrentKp::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCurrentKpT>(new SetCurrentKpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCurrentKp::UnPackTo(SetCurrentKpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kp(); _o->kp = _e; }
}

inline ::flatbuffers::Offset<SetCurrentKp> SetCurrentKp::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCurrentKp(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCurrentKp> CreateSetCurrentKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCurrentKpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kp = _o->kp;
  return MotorControl::CreateSetCurrentKp(
      _fbb,
      _kp);
}

inline SetCurrentKiT *SetCurrentKi::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCurrentKiT>(new SetCurrentKiT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCurrentKi::UnPackTo(SetCurrentKiT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ki(); _o->ki = _e; }
}

inline ::flatbuffers::Offset<SetCurrentKi> SetCurrentKi::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCurrentKi(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCurrentKi> CreateSetCurrentKi(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentKiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCurrentKiT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ki = _o->ki;
  return MotorControl::CreateSetCurrentKi(
      _fbb,
      _ki);
}

inline SetCurrentFilterGainT *SetCurrentFilterGain::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCurrentFilterGainT>(new SetCurrentFilterGainT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCurrentFilterGain::UnPackTo(SetCurrentFilterGainT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gain(); _o->gain = _e; }
}

inline ::flatbuffers::Offset<SetCurrentFilterGain> SetCurrentFilterGain::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentFilterGainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCurrentFilterGain(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCurrentFilterGain> CreateSetCurrentFilterGain(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentFilterGainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCurrentFilterGainT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gain = _o->gain;
  return MotorControl::CreateSetCurrentFilterGain(
      _fbb,
      _gain);
}

inline SetCurrentRefT *SetCurrentRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCurrentRefT>(new SetCurrentRefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCurrentRef::UnPackTo(SetCurrentRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = current_ref(); _o->current_ref = _e; }
}

inline ::flatbuffers::Offset<SetCurrentRef> SetCurrentRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCurrentRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCurrentRef> CreateSetCurrentRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetCurrentRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCurrentRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _current_ref = _o->current_ref;
  return MotorControl::CreateSetCurrentRef(
      _fbb,
      _current_ref);
}

inline SetPositionKpT *SetPositionKp::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetPositionKpT>(new SetPositionKpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetPositionKp::UnPackTo(SetPositionKpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kp(); _o->kp = _e; }
}

inline ::flatbuffers::Offset<SetPositionKp> SetPositionKp::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetPositionKp(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetPositionKp> CreateSetPositionKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetPositionKpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kp = _o->kp;
  return MotorControl::CreateSetPositionKp(
      _fbb,
      _kp);
}

inline SetPositionRefT *SetPositionRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetPositionRefT>(new SetPositionRefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetPositionRef::UnPackTo(SetPositionRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position_ref(); _o->position_ref = _e; }
}

inline ::flatbuffers::Offset<SetPositionRef> SetPositionRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetPositionRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetPositionRef> CreateSetPositionRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetPositionRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetPositionRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position_ref = _o->position_ref;
  return MotorControl::CreateSetPositionRef(
      _fbb,
      _position_ref);
}

inline SetSpeedKpT *SetSpeedKp::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetSpeedKpT>(new SetSpeedKpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetSpeedKp::UnPackTo(SetSpeedKpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kp(); _o->kp = _e; }
}

inline ::flatbuffers::Offset<SetSpeedKp> SetSpeedKp::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetSpeedKp(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetSpeedKp> CreateSetSpeedKp(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetSpeedKpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kp = _o->kp;
  return MotorControl::CreateSetSpeedKp(
      _fbb,
      _kp);
}

inline SetSpeedKiT *SetSpeedKi::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetSpeedKiT>(new SetSpeedKiT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetSpeedKi::UnPackTo(SetSpeedKiT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ki(); _o->ki = _e; }
}

inline ::flatbuffers::Offset<SetSpeedKi> SetSpeedKi::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetSpeedKi(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetSpeedKi> CreateSetSpeedKi(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedKiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetSpeedKiT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ki = _o->ki;
  return MotorControl::CreateSetSpeedKi(
      _fbb,
      _ki);
}

inline SetSpeedRefT *SetSpeedRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetSpeedRefT>(new SetSpeedRefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetSpeedRef::UnPackTo(SetSpeedRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = speed_ref(); _o->speed_ref = _e; }
}

inline ::flatbuffers::Offset<SetSpeedRef> SetSpeedRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetSpeedRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetSpeedRef> CreateSetSpeedRef(::flatbuffers::FlatBufferBuilder &_fbb, const SetSpeedRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetSpeedRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _speed_ref = _o->speed_ref;
  return MotorControl::CreateSetSpeedRef(
      _fbb,
      _speed_ref);
}

inline MotorCommandT *MotorCommand::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MotorCommandT>(new MotorCommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MotorCommand::UnPackTo(MotorCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = motor_id(); _o->motor_id = _e; }
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = MotorControl::MotorCommandsUnion::UnPack(_e, command_type(), _resolver); }
}

inline ::flatbuffers::Offset<MotorCommand> MotorCommand::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MotorCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotorCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MotorCommand> CreateMotorCommand(::flatbuffers::FlatBufferBuilder &_fbb, const MotorCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MotorCommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _motor_id = _o->motor_id;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return MotorControl::CreateMotorCommand(
      _fbb,
      _motor_id,
      _command_type,
      _command);
}

inline EnableExtendedModeT *EnableExtendedMode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnableExtendedModeT>(new EnableExtendedModeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnableExtendedMode::UnPackTo(EnableExtendedModeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<EnableExtendedMode> EnableExtendedMode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnableExtendedModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnableExtendedMode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EnableExtendedMode> CreateEnableExtendedMode(::flatbuffers::FlatBufferBuilder &_fbb, const EnableExtendedModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnableExtendedModeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateEnableExtendedMode(
      _fbb);
}

inline StartMotorT *StartMotor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartMotorT>(new StartMotorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartMotor::UnPackTo(StartMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<StartMotor> StartMotor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartMotor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartMotor> CreateStartMotor(::flatbuffers::FlatBufferBuilder &_fbb, const StartMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartMotorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateStartMotor(
      _fbb);
}

inline TorqueControlModeT *TorqueControlMode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TorqueControlModeT>(new TorqueControlModeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TorqueControlMode::UnPackTo(TorqueControlModeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<TorqueControlMode> TorqueControlMode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TorqueControlModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTorqueControlMode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TorqueControlMode> CreateTorqueControlMode(::flatbuffers::FlatBufferBuilder &_fbb, const TorqueControlModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TorqueControlModeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateTorqueControlMode(
      _fbb);
}

inline SpeedTorqueControlModeT *SpeedTorqueControlMode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpeedTorqueControlModeT>(new SpeedTorqueControlModeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpeedTorqueControlMode::UnPackTo(SpeedTorqueControlModeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SpeedTorqueControlMode> SpeedTorqueControlMode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpeedTorqueControlModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpeedTorqueControlMode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpeedTorqueControlMode> CreateSpeedTorqueControlMode(::flatbuffers::FlatBufferBuilder &_fbb, const SpeedTorqueControlModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpeedTorqueControlModeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateSpeedTorqueControlMode(
      _fbb);
}

inline PositionSpeedTorqueModeT *PositionSpeedTorqueMode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PositionSpeedTorqueModeT>(new PositionSpeedTorqueModeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PositionSpeedTorqueMode::UnPackTo(PositionSpeedTorqueModeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PositionSpeedTorqueMode> PositionSpeedTorqueMode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PositionSpeedTorqueModeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePositionSpeedTorqueMode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PositionSpeedTorqueMode> CreatePositionSpeedTorqueMode(::flatbuffers::FlatBufferBuilder &_fbb, const PositionSpeedTorqueModeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PositionSpeedTorqueModeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreatePositionSpeedTorqueMode(
      _fbb);
}

inline SetMotorPositionToZeroT *SetMotorPositionToZero::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetMotorPositionToZeroT>(new SetMotorPositionToZeroT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetMotorPositionToZero::UnPackTo(SetMotorPositionToZeroT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SetMotorPositionToZero> SetMotorPositionToZero::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMotorPositionToZeroT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetMotorPositionToZero(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetMotorPositionToZero> CreateSetMotorPositionToZero(::flatbuffers::FlatBufferBuilder &_fbb, const SetMotorPositionToZeroT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetMotorPositionToZeroT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MotorControl::CreateSetMotorPositionToZero(
      _fbb);
}

inline MoveMotorT *MoveMotor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoveMotorT>(new MoveMotorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveMotor::UnPackTo(MoveMotorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position_degrees(); _o->position_degrees = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = position_gain(); _o->position_gain = _e; }
  { auto _e = position_damping(); _o->position_damping = _e; }
  { auto _e = torque(); _o->torque = _e; }
}

inline ::flatbuffers::Offset<MoveMotor> MoveMotor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveMotorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveMotor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MoveMotor> CreateMoveMotor(::flatbuffers::FlatBufferBuilder &_fbb, const MoveMotorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MoveMotorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position_degrees = _o->position_degrees;
  auto _speed = _o->speed;
  auto _position_gain = _o->position_gain;
  auto _position_damping = _o->position_damping;
  auto _torque = _o->torque;
  return MotorControl::CreateMoveMotor(
      _fbb,
      _position_degrees,
      _speed,
      _position_gain,
      _position_damping,
      _torque);
}

inline EncoderCommandT *EncoderCommand::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EncoderCommandT>(new EncoderCommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EncoderCommand::UnPackTo(EncoderCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = motor_id(); _o->motor_id = _e; }
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = MotorControl::EncoderCommandsUnion::UnPack(_e, command_type(), _resolver); }
}

inline ::flatbuffers::Offset<EncoderCommand> EncoderCommand::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EncoderCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEncoderCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EncoderCommand> CreateEncoderCommand(::flatbuffers::FlatBufferBuilder &_fbb, const EncoderCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EncoderCommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _motor_id = _o->motor_id;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return MotorControl::CreateEncoderCommand(
      _fbb,
      _motor_id,
      _command_type,
      _command);
}

inline CommandT::CommandT(const CommandT &o)
      : type(o.type),
        motor_control((o.motor_control) ? new MotorControl::MotorCommandT(*o.motor_control) : nullptr),
        encoder_control((o.encoder_control) ? new MotorControl::EncoderCommandT(*o.encoder_control) : nullptr) {
}

inline CommandT &CommandT::operator=(CommandT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(motor_control, o.motor_control);
  std::swap(encoder_control, o.encoder_control);
  return *this;
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CommandT>(new CommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = motor_control(); if (_e) { if(_o->motor_control) { _e->UnPackTo(_o->motor_control.get(), _resolver); } else { _o->motor_control = std::unique_ptr<MotorControl::MotorCommandT>(_e->UnPack(_resolver)); } } else if (_o->motor_control) { _o->motor_control.reset(); } }
  { auto _e = encoder_control(); if (_e) { if(_o->encoder_control) { _e->UnPackTo(_o->encoder_control.get(), _resolver); } else { _o->encoder_control = std::unique_ptr<MotorControl::EncoderCommandT>(_e->UnPack(_resolver)); } } else if (_o->encoder_control) { _o->encoder_control.reset(); } }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _motor_control = _o->motor_control ? CreateMotorCommand(_fbb, _o->motor_control.get(), _rehasher) : 0;
  auto _encoder_control = _o->encoder_control ? CreateEncoderCommand(_fbb, _o->encoder_control.get(), _rehasher) : 0;
  return MotorControl::CreateCommand(
      _fbb,
      _type,
      _motor_control,
      _encoder_control);
}

inline bool VerifyMotorCommands(::flatbuffers::Verifier &verifier, const void *obj, MotorCommands type) {
  switch (type) {
    case MotorCommands_NONE: {
      return true;
    }
    case MotorCommands_InitMotor: {
      auto ptr = reinterpret_cast<const MotorControl::InitMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_EnableMotor: {
      auto ptr = reinterpret_cast<const MotorControl::EnableMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetRunMode: {
      auto ptr = reinterpret_cast<const MotorControl::SetRunMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SendMotionControl: {
      auto ptr = reinterpret_cast<const MotorControl::SendMotionControl *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetLimitSpeed: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitSpeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetLimitCurrent: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitCurrent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetLimitTorque: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitTorque *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetCurrentKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetCurrentKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKi *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetCurrentFilterGain: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentFilterGain *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetCurrentRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetPositionKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionKp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetPositionRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetSpeedKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetSpeedKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKi *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MotorCommands_SetSpeedRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMotorCommandsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMotorCommands(
        verifier,  values->Get(i), types->GetEnum<MotorCommands>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MotorCommandsUnion::UnPack(const void *obj, MotorCommands type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case MotorCommands_InitMotor: {
      auto ptr = reinterpret_cast<const MotorControl::InitMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_EnableMotor: {
      auto ptr = reinterpret_cast<const MotorControl::EnableMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetRunMode: {
      auto ptr = reinterpret_cast<const MotorControl::SetRunMode *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SendMotionControl: {
      auto ptr = reinterpret_cast<const MotorControl::SendMotionControl *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetLimitSpeed: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitSpeed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetLimitCurrent: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitCurrent *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetLimitTorque: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitTorque *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetCurrentKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKp *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetCurrentKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKi *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetCurrentFilterGain: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentFilterGain *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetCurrentRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentRef *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetPositionKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionKp *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetPositionRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionRef *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetSpeedKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKp *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetSpeedKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKi *>(obj);
      return ptr->UnPack(resolver);
    }
    case MotorCommands_SetSpeedRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedRef *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> MotorCommandsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case MotorCommands_InitMotor: {
      auto ptr = reinterpret_cast<const MotorControl::InitMotorT *>(value);
      return CreateInitMotor(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_EnableMotor: {
      auto ptr = reinterpret_cast<const MotorControl::EnableMotorT *>(value);
      return CreateEnableMotor(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotorT *>(value);
      return CreateStopMotor(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetRunMode: {
      auto ptr = reinterpret_cast<const MotorControl::SetRunModeT *>(value);
      return CreateSetRunMode(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SendMotionControl: {
      auto ptr = reinterpret_cast<const MotorControl::SendMotionControlT *>(value);
      return CreateSendMotionControl(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetLimitSpeed: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitSpeedT *>(value);
      return CreateSetLimitSpeed(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetLimitCurrent: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitCurrentT *>(value);
      return CreateSetLimitCurrent(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetLimitTorque: {
      auto ptr = reinterpret_cast<const MotorControl::SetLimitTorqueT *>(value);
      return CreateSetLimitTorque(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetCurrentKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKpT *>(value);
      return CreateSetCurrentKp(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetCurrentKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentKiT *>(value);
      return CreateSetCurrentKi(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetCurrentFilterGain: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentFilterGainT *>(value);
      return CreateSetCurrentFilterGain(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetCurrentRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetCurrentRefT *>(value);
      return CreateSetCurrentRef(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetPositionKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionKpT *>(value);
      return CreateSetPositionKp(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetPositionRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetPositionRefT *>(value);
      return CreateSetPositionRef(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetSpeedKp: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKpT *>(value);
      return CreateSetSpeedKp(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetSpeedKi: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedKiT *>(value);
      return CreateSetSpeedKi(_fbb, ptr, _rehasher).Union();
    }
    case MotorCommands_SetSpeedRef: {
      auto ptr = reinterpret_cast<const MotorControl::SetSpeedRefT *>(value);
      return CreateSetSpeedRef(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MotorCommandsUnion::MotorCommandsUnion(const MotorCommandsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MotorCommands_InitMotor: {
      value = new MotorControl::InitMotorT(*reinterpret_cast<MotorControl::InitMotorT *>(u.value));
      break;
    }
    case MotorCommands_EnableMotor: {
      value = new MotorControl::EnableMotorT(*reinterpret_cast<MotorControl::EnableMotorT *>(u.value));
      break;
    }
    case MotorCommands_StopMotor: {
      value = new MotorControl::StopMotorT(*reinterpret_cast<MotorControl::StopMotorT *>(u.value));
      break;
    }
    case MotorCommands_SetRunMode: {
      value = new MotorControl::SetRunModeT(*reinterpret_cast<MotorControl::SetRunModeT *>(u.value));
      break;
    }
    case MotorCommands_SendMotionControl: {
      value = new MotorControl::SendMotionControlT(*reinterpret_cast<MotorControl::SendMotionControlT *>(u.value));
      break;
    }
    case MotorCommands_SetLimitSpeed: {
      value = new MotorControl::SetLimitSpeedT(*reinterpret_cast<MotorControl::SetLimitSpeedT *>(u.value));
      break;
    }
    case MotorCommands_SetLimitCurrent: {
      value = new MotorControl::SetLimitCurrentT(*reinterpret_cast<MotorControl::SetLimitCurrentT *>(u.value));
      break;
    }
    case MotorCommands_SetLimitTorque: {
      value = new MotorControl::SetLimitTorqueT(*reinterpret_cast<MotorControl::SetLimitTorqueT *>(u.value));
      break;
    }
    case MotorCommands_SetCurrentKp: {
      value = new MotorControl::SetCurrentKpT(*reinterpret_cast<MotorControl::SetCurrentKpT *>(u.value));
      break;
    }
    case MotorCommands_SetCurrentKi: {
      value = new MotorControl::SetCurrentKiT(*reinterpret_cast<MotorControl::SetCurrentKiT *>(u.value));
      break;
    }
    case MotorCommands_SetCurrentFilterGain: {
      value = new MotorControl::SetCurrentFilterGainT(*reinterpret_cast<MotorControl::SetCurrentFilterGainT *>(u.value));
      break;
    }
    case MotorCommands_SetCurrentRef: {
      value = new MotorControl::SetCurrentRefT(*reinterpret_cast<MotorControl::SetCurrentRefT *>(u.value));
      break;
    }
    case MotorCommands_SetPositionKp: {
      value = new MotorControl::SetPositionKpT(*reinterpret_cast<MotorControl::SetPositionKpT *>(u.value));
      break;
    }
    case MotorCommands_SetPositionRef: {
      value = new MotorControl::SetPositionRefT(*reinterpret_cast<MotorControl::SetPositionRefT *>(u.value));
      break;
    }
    case MotorCommands_SetSpeedKp: {
      value = new MotorControl::SetSpeedKpT(*reinterpret_cast<MotorControl::SetSpeedKpT *>(u.value));
      break;
    }
    case MotorCommands_SetSpeedKi: {
      value = new MotorControl::SetSpeedKiT(*reinterpret_cast<MotorControl::SetSpeedKiT *>(u.value));
      break;
    }
    case MotorCommands_SetSpeedRef: {
      value = new MotorControl::SetSpeedRefT(*reinterpret_cast<MotorControl::SetSpeedRefT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MotorCommandsUnion::Reset() {
  switch (type) {
    case MotorCommands_InitMotor: {
      auto ptr = reinterpret_cast<MotorControl::InitMotorT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_EnableMotor: {
      auto ptr = reinterpret_cast<MotorControl::EnableMotorT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_StopMotor: {
      auto ptr = reinterpret_cast<MotorControl::StopMotorT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetRunMode: {
      auto ptr = reinterpret_cast<MotorControl::SetRunModeT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SendMotionControl: {
      auto ptr = reinterpret_cast<MotorControl::SendMotionControlT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetLimitSpeed: {
      auto ptr = reinterpret_cast<MotorControl::SetLimitSpeedT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetLimitCurrent: {
      auto ptr = reinterpret_cast<MotorControl::SetLimitCurrentT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetLimitTorque: {
      auto ptr = reinterpret_cast<MotorControl::SetLimitTorqueT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetCurrentKp: {
      auto ptr = reinterpret_cast<MotorControl::SetCurrentKpT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetCurrentKi: {
      auto ptr = reinterpret_cast<MotorControl::SetCurrentKiT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetCurrentFilterGain: {
      auto ptr = reinterpret_cast<MotorControl::SetCurrentFilterGainT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetCurrentRef: {
      auto ptr = reinterpret_cast<MotorControl::SetCurrentRefT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetPositionKp: {
      auto ptr = reinterpret_cast<MotorControl::SetPositionKpT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetPositionRef: {
      auto ptr = reinterpret_cast<MotorControl::SetPositionRefT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetSpeedKp: {
      auto ptr = reinterpret_cast<MotorControl::SetSpeedKpT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetSpeedKi: {
      auto ptr = reinterpret_cast<MotorControl::SetSpeedKiT *>(value);
      delete ptr;
      break;
    }
    case MotorCommands_SetSpeedRef: {
      auto ptr = reinterpret_cast<MotorControl::SetSpeedRefT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MotorCommands_NONE;
}

inline bool VerifyEncoderCommands(::flatbuffers::Verifier &verifier, const void *obj, EncoderCommands type) {
  switch (type) {
    case EncoderCommands_NONE: {
      return true;
    }
    case EncoderCommands_EnableExtendedMode: {
      auto ptr = reinterpret_cast<const MotorControl::EnableExtendedMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_StartMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StartMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_TorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::TorqueControlMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_SpeedTorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::SpeedTorqueControlMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_PositionSpeedTorqueMode: {
      auto ptr = reinterpret_cast<const MotorControl::PositionSpeedTorqueMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_SetMotorPositionToZero: {
      auto ptr = reinterpret_cast<const MotorControl::SetMotorPositionToZero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncoderCommands_MoveMotor: {
      auto ptr = reinterpret_cast<const MotorControl::MoveMotor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEncoderCommandsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEncoderCommands(
        verifier,  values->Get(i), types->GetEnum<EncoderCommands>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EncoderCommandsUnion::UnPack(const void *obj, EncoderCommands type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case EncoderCommands_EnableExtendedMode: {
      auto ptr = reinterpret_cast<const MotorControl::EnableExtendedMode *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_StartMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StartMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_TorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::TorqueControlMode *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_SpeedTorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::SpeedTorqueControlMode *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_PositionSpeedTorqueMode: {
      auto ptr = reinterpret_cast<const MotorControl::PositionSpeedTorqueMode *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_SetMotorPositionToZero: {
      auto ptr = reinterpret_cast<const MotorControl::SetMotorPositionToZero *>(obj);
      return ptr->UnPack(resolver);
    }
    case EncoderCommands_MoveMotor: {
      auto ptr = reinterpret_cast<const MotorControl::MoveMotor *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EncoderCommandsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case EncoderCommands_EnableExtendedMode: {
      auto ptr = reinterpret_cast<const MotorControl::EnableExtendedModeT *>(value);
      return CreateEnableExtendedMode(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_StartMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StartMotorT *>(value);
      return CreateStartMotor(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_StopMotor: {
      auto ptr = reinterpret_cast<const MotorControl::StopMotorT *>(value);
      return CreateStopMotor(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_TorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::TorqueControlModeT *>(value);
      return CreateTorqueControlMode(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_SpeedTorqueControlMode: {
      auto ptr = reinterpret_cast<const MotorControl::SpeedTorqueControlModeT *>(value);
      return CreateSpeedTorqueControlMode(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_PositionSpeedTorqueMode: {
      auto ptr = reinterpret_cast<const MotorControl::PositionSpeedTorqueModeT *>(value);
      return CreatePositionSpeedTorqueMode(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_SetMotorPositionToZero: {
      auto ptr = reinterpret_cast<const MotorControl::SetMotorPositionToZeroT *>(value);
      return CreateSetMotorPositionToZero(_fbb, ptr, _rehasher).Union();
    }
    case EncoderCommands_MoveMotor: {
      auto ptr = reinterpret_cast<const MotorControl::MoveMotorT *>(value);
      return CreateMoveMotor(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EncoderCommandsUnion::EncoderCommandsUnion(const EncoderCommandsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case EncoderCommands_EnableExtendedMode: {
      value = new MotorControl::EnableExtendedModeT(*reinterpret_cast<MotorControl::EnableExtendedModeT *>(u.value));
      break;
    }
    case EncoderCommands_StartMotor: {
      value = new MotorControl::StartMotorT(*reinterpret_cast<MotorControl::StartMotorT *>(u.value));
      break;
    }
    case EncoderCommands_StopMotor: {
      value = new MotorControl::StopMotorT(*reinterpret_cast<MotorControl::StopMotorT *>(u.value));
      break;
    }
    case EncoderCommands_TorqueControlMode: {
      value = new MotorControl::TorqueControlModeT(*reinterpret_cast<MotorControl::TorqueControlModeT *>(u.value));
      break;
    }
    case EncoderCommands_SpeedTorqueControlMode: {
      value = new MotorControl::SpeedTorqueControlModeT(*reinterpret_cast<MotorControl::SpeedTorqueControlModeT *>(u.value));
      break;
    }
    case EncoderCommands_PositionSpeedTorqueMode: {
      value = new MotorControl::PositionSpeedTorqueModeT(*reinterpret_cast<MotorControl::PositionSpeedTorqueModeT *>(u.value));
      break;
    }
    case EncoderCommands_SetMotorPositionToZero: {
      value = new MotorControl::SetMotorPositionToZeroT(*reinterpret_cast<MotorControl::SetMotorPositionToZeroT *>(u.value));
      break;
    }
    case EncoderCommands_MoveMotor: {
      value = new MotorControl::MoveMotorT(*reinterpret_cast<MotorControl::MoveMotorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EncoderCommandsUnion::Reset() {
  switch (type) {
    case EncoderCommands_EnableExtendedMode: {
      auto ptr = reinterpret_cast<MotorControl::EnableExtendedModeT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_StartMotor: {
      auto ptr = reinterpret_cast<MotorControl::StartMotorT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_StopMotor: {
      auto ptr = reinterpret_cast<MotorControl::StopMotorT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_TorqueControlMode: {
      auto ptr = reinterpret_cast<MotorControl::TorqueControlModeT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_SpeedTorqueControlMode: {
      auto ptr = reinterpret_cast<MotorControl::SpeedTorqueControlModeT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_PositionSpeedTorqueMode: {
      auto ptr = reinterpret_cast<MotorControl::PositionSpeedTorqueModeT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_SetMotorPositionToZero: {
      auto ptr = reinterpret_cast<MotorControl::SetMotorPositionToZeroT *>(value);
      delete ptr;
      break;
    }
    case EncoderCommands_MoveMotor: {
      auto ptr = reinterpret_cast<MotorControl::MoveMotorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = EncoderCommands_NONE;
}

inline const MotorControl::Command *GetCommand(const void *buf) {
  return ::flatbuffers::GetRoot<MotorControl::Command>(buf);
}

inline const MotorControl::Command *GetSizePrefixedCommand(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MotorControl::Command>(buf);
}

inline bool VerifyCommandBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MotorControl::Command>(nullptr);
}

inline bool VerifySizePrefixedCommandBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MotorControl::Command>(nullptr);
}

inline void FinishCommandBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotorControl::Command> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCommandBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MotorControl::Command> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<MotorControl::CommandT> UnPackCommand(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MotorControl::CommandT>(GetCommand(buf)->UnPack(res));
}

inline std::unique_ptr<MotorControl::CommandT> UnPackSizePrefixedCommand(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MotorControl::CommandT>(GetSizePrefixedCommand(buf)->UnPack(res));
}

}  // namespace MotorControl

#endif  // FLATBUFFERS_GENERATED_DEBUGROTARYENCODER_MOTORCONTROL_H_
